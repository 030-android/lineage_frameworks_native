From bef4966ad22d7690626b3dc048c59cb9e9eab870 Mon Sep 17 00:00:00 2001
From: Jesse Hall <jessehall@google.com>
Date: Sun, 29 Nov 2015 23:50:38 -0800
Subject: [PATCH] vulkan: Update from version 0.196.0 to 0.197.0

Change-Id: I1c7aecd276cb8d831b8d7bf7eef58b5c6ad8b82c
---
 vulkan/api/vulkan.api          | 24 ++++++++++++------------
 vulkan/include/vulkan/vulkan.h | 22 ++++++++++------------
 vulkan/nulldrv/null_driver.cpp |  7 +++++--
 vulkan/tools/vkinfo.cpp        | 16 ++++++++--------
 4 files changed, 35 insertions(+), 34 deletions(-)

diff --git a/vulkan/api/vulkan.api b/vulkan/api/vulkan.api
index 7313904..9575407 100644
--- a/vulkan/api/vulkan.api
+++ b/vulkan/api/vulkan.api
@@ -27,7 +27,7 @@ import platform "platform.api"
 
 // API version (major.minor.patch)
 define VERSION_MAJOR 0
-define VERSION_MINOR 196
+define VERSION_MINOR 197
 define VERSION_PATCH 0
 
 // API limits
@@ -723,18 +723,17 @@ bitfield VkQueueFlagBits {
 /// Memory properties passed into vkAllocMemory().
 type VkFlags VkMemoryPropertyFlags
 bitfield VkMemoryPropertyFlagBits {
-    VK_MEMORY_PROPERTY_DEVICE_ONLY                          = 0x00000000,    /// If otherwise stated, then allocate memory on device
-    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT                     = 0x00000001,    /// Memory should be mappable by host
-    VK_MEMORY_PROPERTY_HOST_NON_COHERENT_BIT                = 0x00000002,    /// Memory may not have i/o coherency so vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges must be used flush/invalidate host cache
-                                                                             /// vkInvalidateMappedMemoryRanges must be used flush/invalidate host cache
-    VK_MEMORY_PROPERTY_HOST_UNCACHED_BIT                    = 0x00000004,    /// Memory should not be cached by the host
-    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT                 = 0x00000008,    /// Memory may be allocated by the driver when it is required
+    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT                     = 0x00000001,
+    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT                     = 0x00000002,
+    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT                    = 0x00000004,
+    VK_MEMORY_PROPERTY_HOST_CACHED_BIT                      = 0x00000008,
+    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT                 = 0x00000010,
 }
 
 /// Memory heap flags
 type VkFlags VkMemoryHeapFlags
 bitfield VkMemoryHeapFlagBits {
-    VK_MEMORY_HEAP_HOST_LOCAL_BIT                           = 0x00000001,    /// If set, heap represents host memory
+    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT                         = 0x00000001,
 }
 
 /// Memory output flags passed to resource transition commands
@@ -953,9 +952,8 @@ bitfield VkImageAspectFlagBits {
 
 /// Sparse memory bind flags
 type VkFlags VkSparseMemoryBindFlags
-bitfield VkSparseMemoryBindFlagBits {
-    VK_SPARSE_MEMORY_BIND_REPLICATE_BLOCK_BIT               = 0x00000001,
-}
+//bitfield VkSparseMemoryBindFlagBits {
+//}
 
 /// Sparse image memory requirements flags
 type VkFlags VkSparseImageFormatFlags
@@ -2076,6 +2074,8 @@ class VkPhysicalDeviceFeatures {
     VkBool32                                    shaderImageGatherExtended                 /// texture gather with run-time values and independent offsets
     VkBool32                                    shaderStorageImageExtendedFormats         /// the extended set of formats can be used for storage images
     VkBool32                                    shaderStorageImageMultisample             /// multisample images can be used for storage images
+    VkBool32                                    shaderStorageImageReadWithoutFormat
+    VkBool32                                    shaderStorageImageWriteWithoutFormat
     VkBool32                                    shaderUniformBufferArrayDynamicIndexing   /// arrays of uniform buffers can be accessed with dynamically uniform indices
     VkBool32                                    shaderSampledImageArrayDynamicIndexing    /// arrays of sampled images can be accessed with dynamically uniform indices
     VkBool32                                    shaderStorageBufferArrayDynamicIndexing   /// arrays of storage buffers can be accessed with dynamically uniform indices
@@ -2096,6 +2096,7 @@ class VkPhysicalDeviceFeatures {
     VkBool32                                    sparseResidency8Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
     VkBool32                                    sparseResidency16Samples                  /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
     VkBool32                                    sparseResidencyAliased                    /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
+    VkBool32                                    variableMultisampleRate
 }
 
 class VkPhysicalDeviceLimits {
@@ -2226,7 +2227,6 @@ class VkPhysicalDeviceSparseProperties {
     VkBool32                                    residencyStandard2DMultisampleBlockShape  /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format)
     VkBool32                                    residencyStandard3DBlockShape             /// Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format)
     VkBool32                                    residencyAlignedMipSize                   /// Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail
-    VkBool32                                    residencyNonResident                      /// Sparse resources support: GPU can safely access non-resident regions of a resource, read values from read-write resources are undefined
     VkBool32                                    residencyNonResidentStrict                /// Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
 }
 
diff --git a/vulkan/include/vulkan/vulkan.h b/vulkan/include/vulkan/vulkan.h
index 0130399..cbd15e6 100644
--- a/vulkan/include/vulkan/vulkan.h
+++ b/vulkan/include/vulkan/vulkan.h
@@ -41,7 +41,7 @@ extern "C" {
     ((major << 22) | (minor << 12) | patch)
 
 // Vulkan API version supported by this file
-#define VK_API_VERSION VK_MAKE_VERSION(0, 196, 0)
+#define VK_API_VERSION VK_MAKE_VERSION(0, 197, 0)
 
 
 #define VK_NULL_HANDLE 0
@@ -810,16 +810,16 @@ typedef enum {
 typedef VkFlags VkQueueFlags;
 
 typedef enum {
-    VK_MEMORY_PROPERTY_DEVICE_ONLY = 0,
-    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000001,
-    VK_MEMORY_PROPERTY_HOST_NON_COHERENT_BIT = 0x00000002,
-    VK_MEMORY_PROPERTY_HOST_UNCACHED_BIT = 0x00000004,
-    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000008,
+    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
+    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
+    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
+    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
+    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
 } VkMemoryPropertyFlagBits;
 typedef VkFlags VkMemoryPropertyFlags;
 
 typedef enum {
-    VK_MEMORY_HEAP_HOST_LOCAL_BIT = 0x00000001,
+    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
 } VkMemoryHeapFlagBits;
 typedef VkFlags VkMemoryHeapFlags;
 typedef VkFlags VkDeviceCreateFlags;
@@ -839,10 +839,6 @@ typedef enum {
     VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0x00000004,
 } VkSparseImageFormatFlagBits;
 typedef VkFlags VkSparseImageFormatFlags;
-
-typedef enum {
-    VK_SPARSE_MEMORY_BIND_REPLICATE_BLOCK_BIT = 0x00000001,
-} VkSparseMemoryBindFlagBits;
 typedef VkFlags VkSparseMemoryBindFlags;
 
 typedef enum {
@@ -1141,6 +1137,8 @@ typedef struct {
     VkBool32                                    shaderImageGatherExtended;
     VkBool32                                    shaderStorageImageExtendedFormats;
     VkBool32                                    shaderStorageImageMultisample;
+    VkBool32                                    shaderStorageImageReadWithoutFormat;
+    VkBool32                                    shaderStorageImageWriteWithoutFormat;
     VkBool32                                    shaderUniformBufferArrayDynamicIndexing;
     VkBool32                                    shaderSampledImageArrayDynamicIndexing;
     VkBool32                                    shaderStorageBufferArrayDynamicIndexing;
@@ -1161,6 +1159,7 @@ typedef struct {
     VkBool32                                    sparseResidency8Samples;
     VkBool32                                    sparseResidency16Samples;
     VkBool32                                    sparseResidencyAliased;
+    VkBool32                                    variableMultisampleRate;
 } VkPhysicalDeviceFeatures;
 
 typedef struct {
@@ -1290,7 +1289,6 @@ typedef struct {
     VkBool32                                    residencyStandard2DMultisampleBlockShape;
     VkBool32                                    residencyStandard3DBlockShape;
     VkBool32                                    residencyAlignedMipSize;
-    VkBool32                                    residencyNonResident;
     VkBool32                                    residencyNonResidentStrict;
 } VkPhysicalDeviceSparseProperties;
 
diff --git a/vulkan/nulldrv/null_driver.cpp b/vulkan/nulldrv/null_driver.cpp
index d134c0e..b2b905f 100644
--- a/vulkan/nulldrv/null_driver.cpp
+++ b/vulkan/nulldrv/null_driver.cpp
@@ -292,11 +292,14 @@ void GetPhysicalDeviceMemoryProperties(
     VkPhysicalDeviceMemoryProperties* properties) {
     properties->memoryTypeCount = 1;
     properties->memoryTypes[0].propertyFlags =
-        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
+        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT |
+        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |
+        VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
+        VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
     properties->memoryTypes[0].heapIndex = 0;
     properties->memoryHeapCount = 1;
     properties->memoryHeaps[0].size = kMaxDeviceMemory;
-    properties->memoryHeaps[0].flags = VK_MEMORY_HEAP_HOST_LOCAL_BIT;
+    properties->memoryHeaps[0].flags = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT;
 }
 
 // -----------------------------------------------------------------------------
diff --git a/vulkan/tools/vkinfo.cpp b/vulkan/tools/vkinfo.cpp
index 838d0e2..1920d6b 100644
--- a/vulkan/tools/vkinfo.cpp
+++ b/vulkan/tools/vkinfo.cpp
@@ -98,8 +98,8 @@ void DumpPhysicalDevice(uint32_t idx, VkPhysicalDevice pdev) {
     vkGetPhysicalDeviceMemoryProperties(pdev, &mem_props);
     for (uint32_t heap = 0; heap < mem_props.memoryHeapCount; heap++) {
         if ((mem_props.memoryHeaps[heap].flags &
-             VK_MEMORY_HEAP_HOST_LOCAL_BIT) != 0)
-            strbuf << "HOST_LOCAL";
+             VK_MEMORY_HEAP_DEVICE_LOCAL_BIT) != 0)
+            strbuf << "DEVICE_LOCAL";
         printf("     Heap %u: 0x%" PRIx64 " %s\n", heap,
                mem_props.memoryHeaps[heap].size, strbuf.str().c_str());
         strbuf.str(std::string());
@@ -109,14 +109,14 @@ void DumpPhysicalDevice(uint32_t idx, VkPhysicalDevice pdev) {
                 continue;
             VkMemoryPropertyFlags flags =
                 mem_props.memoryTypes[type].propertyFlags;
-            if (flags == VK_MEMORY_PROPERTY_DEVICE_ONLY)
-                strbuf << "DEVICE_ONLY";
+            if ((flags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) != 0)
+                strbuf << "DEVICE_LOCAL";
             if ((flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) != 0)
                 strbuf << "HOST_VISIBLE";
-            if ((flags & VK_MEMORY_PROPERTY_HOST_NON_COHERENT_BIT) != 0)
-                strbuf << " NON_COHERENT";
-            if ((flags & VK_MEMORY_PROPERTY_HOST_UNCACHED_BIT) != 0)
-                strbuf << " UNCACHED";
+            if ((flags & VK_MEMORY_PROPERTY_HOST_COHERENT_BIT) != 0)
+                strbuf << " COHERENT";
+            if ((flags & VK_MEMORY_PROPERTY_HOST_CACHED_BIT) != 0)
+                strbuf << " CACHED";
             if ((flags & VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT) != 0)
                 strbuf << " LAZILY_ALLOCATED";
             printf("       Type %u: %s\n", type, strbuf.str().c_str());
-- 
2.6.0.rc2.230.g3dd15c0

