// Copyright (c) 2015 The Khronos Group Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and/or associated documentation files (the
// "Materials"), to deal in the Materials without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Materials, and to
// permit persons to whom the Materials are furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Materials.
//
// THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
// MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.

import platform "platform.api"

///////////////
// Constants //
///////////////

// API version (major.minor.patch)
define VERSION_MAJOR 0
define VERSION_MINOR 174
define VERSION_PATCH 0

// API limits
define VK_MAX_PHYSICAL_DEVICE_NAME 256
define VK_UUID_LENGTH              16
define VK_MAX_EXTENSION_NAME       256
define VK_MAX_DESCRIPTION          256
define VK_MAX_MEMORY_TYPES         32
define VK_MAX_MEMORY_HEAPS         16    /// The maximum number of unique memory heaps, each of which supporting 1 or more memory types.

// API keywords
define VK_TRUE        1
define VK_FALSE       0

// API keyword, but needs special handling by some templates
define NULL_HANDLE 0


/////////////
//  Types  //
/////////////

type u32 VkBool32
type u32 VkFlags
type u64 VkDeviceSize
type u32 VkSampleMask

/// Dispatchable handle types.
@dispatchHandle type u64 VkInstance
@dispatchHandle type u64 VkPhysicalDevice
@dispatchHandle type u64 VkDevice
@dispatchHandle type u64 VkQueue
@dispatchHandle type u64 VkCmdBuffer

/// Non dispatchable handle types.
@nonDispatchHandle type u64 VkDeviceMemory
@nonDispatchHandle type u64 VkCmdPool
@nonDispatchHandle type u64 VkBuffer
@nonDispatchHandle type u64 VkBufferView
@nonDispatchHandle type u64 VkImage
@nonDispatchHandle type u64 VkImageView
@nonDispatchHandle type u64 VkShaderModule
@nonDispatchHandle type u64 VkShader
@nonDispatchHandle type u64 VkPipeline
@nonDispatchHandle type u64 VkPipelineLayout
@nonDispatchHandle type u64 VkSampler
@nonDispatchHandle type u64 VkDescriptorSet
@nonDispatchHandle type u64 VkDescriptorSetLayout
@nonDispatchHandle type u64 VkDescriptorPool
@nonDispatchHandle type u64 VkFence
@nonDispatchHandle type u64 VkSemaphore
@nonDispatchHandle type u64 VkEvent
@nonDispatchHandle type u64 VkQueryPool
@nonDispatchHandle type u64 VkFramebuffer
@nonDispatchHandle type u64 VkRenderPass
@nonDispatchHandle type u64 VkPipelineCache
@nonDispatchHandle type u64 VkSwapchainKHR


/////////////
//  Enums  //
/////////////

enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED                               = 0x00000000,   /// Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
    VK_IMAGE_LAYOUT_GENERAL                                 = 0x00000001,   /// General layout when image can be used for any kind of access
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL                = 0x00000002,   /// Optimal layout when image is only used for color attachment read/write
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL        = 0x00000003,   /// Optimal layout when image is only used for depth/stencil attachment read/write
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL         = 0x00000004,   /// Optimal layout when image is used for read only depth/stencil attachment and shader access
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL                = 0x00000005,   /// Optimal layout when image is used for read only shader access
    VK_IMAGE_LAYOUT_TRANSFER_SOURCE_OPTIMAL                 = 0x00000006,   /// Optimal layout when image is used only as source of transfer operations
    VK_IMAGE_LAYOUT_TRANSFER_DESTINATION_OPTIMAL            = 0x00000007,   /// Optimal layout when image is used only as destination of transfer operations
    VK_IMAGE_LAYOUT_PREINITIALIZED                          = 0x00000008,   /// Initial layout used when the data is populated by the CPU
}

enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD                              = 0x00000000,
    VK_ATTACHMENT_LOAD_OP_CLEAR                             = 0x00000001,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE                         = 0x00000002,
}

enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE                            = 0x00000000,
    VK_ATTACHMENT_STORE_OP_DONT_CARE                        = 0x00000001,
}

enum VkImageType {
    VK_IMAGE_TYPE_1D                                        = 0x00000000,
    VK_IMAGE_TYPE_2D                                        = 0x00000001,
    VK_IMAGE_TYPE_3D                                        = 0x00000002,
}

enum VkImageTiling {
    VK_IMAGE_TILING_LINEAR                                  = 0x00000000,
    VK_IMAGE_TILING_OPTIMAL                                 = 0x00000001,
}

enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D                                   = 0x00000000,
    VK_IMAGE_VIEW_TYPE_2D                                   = 0x00000001,
    VK_IMAGE_VIEW_TYPE_3D                                   = 0x00000002,
    VK_IMAGE_VIEW_TYPE_CUBE                                 = 0x00000003,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY                             = 0x00000004,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY                             = 0x00000005,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY                           = 0x00000006,
}

enum VkImageAspect {
    VK_IMAGE_ASPECT_COLOR                                   = 0x00000000,
    VK_IMAGE_ASPECT_DEPTH                                   = 0x00000001,
    VK_IMAGE_ASPECT_STENCIL                                 = 0x00000002,
    VK_IMAGE_ASPECT_METADATA                                = 0x00000003,
}

enum VkCmdBufferLevel {
    VK_CMD_BUFFER_LEVEL_PRIMARY                             = 0x00000000,
    VK_CMD_BUFFER_LEVEL_SECONDARY                           = 0x00000001,
}

enum VkChannelSwizzle {
    VK_CHANNEL_SWIZZLE_ZERO                                 = 0x00000000,
    VK_CHANNEL_SWIZZLE_ONE                                  = 0x00000001,
    VK_CHANNEL_SWIZZLE_R                                    = 0x00000002,
    VK_CHANNEL_SWIZZLE_G                                    = 0x00000003,
    VK_CHANNEL_SWIZZLE_B                                    = 0x00000004,
    VK_CHANNEL_SWIZZLE_A                                    = 0x00000005,
}

enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER                              = 0x00000000,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER               = 0x00000001,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE                        = 0x00000002,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE                        = 0x00000003,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER                 = 0x00000004,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER                 = 0x00000005,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER                       = 0x00000006,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER                       = 0x00000007,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC               = 0x00000008,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC               = 0x00000009,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT                     = 0x0000000a,
}

enum VkDescriptorPoolUsage {
    VK_DESCRIPTOR_POOL_USAGE_ONE_SHOT                       = 0x00000000,
    VK_DESCRIPTOR_POOL_USAGE_DYNAMIC                        = 0x00000001,
}

enum VkDescriptorSetUsage {
    VK_DESCRIPTOR_SET_USAGE_ONE_SHOT                        = 0x00000000,
    VK_DESCRIPTOR_SET_USAGE_STATIC                          = 0x00000001,
}

enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION                                 = 0x00000000,
    VK_QUERY_TYPE_PIPELINE_STATISTICS                       = 0x00000001, /// Optional
}

enum VkTimestampType {
    VK_TIMESTAMP_TYPE_TOP                                   = 0x00000000,
    VK_TIMESTAMP_TYPE_BOTTOM                                = 0x00000001,
}

enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK                 = 0x00000000,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK                   = 0x00000001,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK                      = 0x00000002,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK                        = 0x00000003,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE                      = 0x00000004,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE                        = 0x00000005,
}

enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_COMPUTE                          = 0x00000000,
    VK_PIPELINE_BIND_POINT_GRAPHICS                         = 0x00000001,
}

enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST                        = 0x00000000,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST                         = 0x00000001,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP                        = 0x00000002,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST                     = 0x00000003,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP                    = 0x00000004,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN                      = 0x00000005,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_ADJ                     = 0x00000006,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_ADJ                    = 0x00000007,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_ADJ                 = 0x00000008,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_ADJ                = 0x00000009,
    VK_PRIMITIVE_TOPOLOGY_PATCH                             = 0x0000000a,
}

enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE                               = 0x00000000,
    VK_SHARING_MODE_CONCURRENT                              = 0x00000001,
}

enum VkIndexType {
    VK_INDEX_TYPE_UINT16                                    = 0x00000000,
    VK_INDEX_TYPE_UINT32                                    = 0x00000001,
}

enum VkTexFilter {
    VK_TEX_FILTER_NEAREST                                   = 0x00000000,
    VK_TEX_FILTER_LINEAR                                    = 0x00000001,
}

enum VkTexMipmapMode {
    VK_TEX_MIPMAP_MODE_BASE                                 = 0x00000000,   /// Always choose base level
    VK_TEX_MIPMAP_MODE_NEAREST                              = 0x00000001,   /// Choose nearest mip level
    VK_TEX_MIPMAP_MODE_LINEAR                               = 0x00000002,   /// Linear filter between mip levels
}

enum VkTexAddressMode {
    VK_TEX_ADDRESS_MODE_WRAP                                = 0x00000000,
    VK_TEX_ADDRESS_MODE_MIRROR                              = 0x00000001,
    VK_TEX_ADDRESS_MODE_CLAMP                               = 0x00000002,
    VK_TEX_ADDRESS_MODE_MIRROR_ONCE                         = 0x00000003,
    VK_TEX_ADDRESS_MODE_CLAMP_BORDER                        = 0x00000004,
}

enum VkCompareOp {
    VK_COMPARE_OP_NEVER                                     = 0x00000000,
    VK_COMPARE_OP_LESS                                      = 0x00000001,
    VK_COMPARE_OP_EQUAL                                     = 0x00000002,
    VK_COMPARE_OP_LESS_EQUAL                                = 0x00000003,
    VK_COMPARE_OP_GREATER                                   = 0x00000004,
    VK_COMPARE_OP_NOT_EQUAL                                 = 0x00000005,
    VK_COMPARE_OP_GREATER_EQUAL                             = 0x00000006,
    VK_COMPARE_OP_ALWAYS                                    = 0x00000007,
}

enum VkFillMode {
    VK_FILL_MODE_POINTS                                     = 0x00000000,
    VK_FILL_MODE_WIREFRAME                                  = 0x00000001,
    VK_FILL_MODE_SOLID                                      = 0x00000002,
}

enum VkCullMode {
    VK_CULL_MODE_NONE                                       = 0x00000000,
    VK_CULL_MODE_FRONT                                      = 0x00000001,
    VK_CULL_MODE_BACK                                       = 0x00000002,
    VK_CULL_MODE_FRONT_AND_BACK                             = 0x00000003,
}

enum VkFrontFace {
    VK_FRONT_FACE_CCW                                       = 0x00000000,
    VK_FRONT_FACE_CW                                        = 0x00000001,
}

enum VkBlend {
    VK_BLEND_ZERO                                           = 0x00000000,
    VK_BLEND_ONE                                            = 0x00000001,
    VK_BLEND_SRC_COLOR                                      = 0x00000002,
    VK_BLEND_ONE_MINUS_SRC_COLOR                            = 0x00000003,
    VK_BLEND_DEST_COLOR                                     = 0x00000004,
    VK_BLEND_ONE_MINUS_DEST_COLOR                           = 0x00000005,
    VK_BLEND_SRC_ALPHA                                      = 0x00000006,
    VK_BLEND_ONE_MINUS_SRC_ALPHA                            = 0x00000007,
    VK_BLEND_DEST_ALPHA                                     = 0x00000008,
    VK_BLEND_ONE_MINUS_DEST_ALPHA                           = 0x00000009,
    VK_BLEND_CONSTANT_COLOR                                 = 0x0000000a,
    VK_BLEND_ONE_MINUS_CONSTANT_COLOR                       = 0x0000000b,
    VK_BLEND_CONSTANT_ALPHA                                 = 0x0000000c,
    VK_BLEND_ONE_MINUS_CONSTANT_ALPHA                       = 0x0000000d,
    VK_BLEND_SRC_ALPHA_SATURATE                             = 0x0000000e,
    VK_BLEND_SRC1_COLOR                                     = 0x0000000f,
    VK_BLEND_ONE_MINUS_SRC1_COLOR                           = 0x00000010,
    VK_BLEND_SRC1_ALPHA                                     = 0x00000011,
    VK_BLEND_ONE_MINUS_SRC1_ALPHA                           = 0x00000012,
}

enum VkBlendOp {
    VK_BLEND_OP_ADD                                         = 0x00000000,
    VK_BLEND_OP_SUBTRACT                                    = 0x00000001,
    VK_BLEND_OP_REVERSE_SUBTRACT                            = 0x00000002,
    VK_BLEND_OP_MIN                                         = 0x00000003,
    VK_BLEND_OP_MAX                                         = 0x00000004,
}

enum VkStencilOp {
    VK_STENCIL_OP_KEEP                                      = 0x00000000,
    VK_STENCIL_OP_ZERO                                      = 0x00000001,
    VK_STENCIL_OP_REPLACE                                   = 0x00000002,
    VK_STENCIL_OP_INC_CLAMP                                 = 0x00000003,
    VK_STENCIL_OP_DEC_CLAMP                                 = 0x00000004,
    VK_STENCIL_OP_INVERT                                    = 0x00000005,
    VK_STENCIL_OP_INC_WRAP                                  = 0x00000006,
    VK_STENCIL_OP_DEC_WRAP                                  = 0x00000007,
}

enum VkLogicOp {
    VK_LOGIC_OP_CLEAR                                       = 0x00000000,
    VK_LOGIC_OP_AND                                         = 0x00000001,
    VK_LOGIC_OP_AND_REVERSE                                 = 0x00000002,
    VK_LOGIC_OP_COPY                                        = 0x00000003,
    VK_LOGIC_OP_AND_INVERTED                                = 0x00000004,
    VK_LOGIC_OP_NOOP                                        = 0x00000005,
    VK_LOGIC_OP_XOR                                         = 0x00000006,
    VK_LOGIC_OP_OR                                          = 0x00000007,
    VK_LOGIC_OP_NOR                                         = 0x00000008,
    VK_LOGIC_OP_EQUIV                                       = 0x00000009,
    VK_LOGIC_OP_INVERT                                      = 0x0000000a,
    VK_LOGIC_OP_OR_REVERSE                                  = 0x0000000b,
    VK_LOGIC_OP_COPY_INVERTED                               = 0x0000000c,
    VK_LOGIC_OP_OR_INVERTED                                 = 0x0000000d,
    VK_LOGIC_OP_NAND                                        = 0x0000000e,
    VK_LOGIC_OP_SET                                         = 0x0000000f,
}

enum VkSystemAllocType {
    VK_SYSTEM_ALLOC_TYPE_API_OBJECT                         = 0x00000000,
    VK_SYSTEM_ALLOC_TYPE_INTERNAL                           = 0x00000001,
    VK_SYSTEM_ALLOC_TYPE_INTERNAL_TEMP                      = 0x00000002,
    VK_SYSTEM_ALLOC_TYPE_INTERNAL_SHADER                    = 0x00000003,
    VK_SYSTEM_ALLOC_TYPE_DEBUG                              = 0x00000004,
}

enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER                           = 0x00000000,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU                  = 0x00000001,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU                    = 0x00000002,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU                     = 0x00000003,
    VK_PHYSICAL_DEVICE_TYPE_CPU                             = 0x00000004,
}

enum VkVertexInputStepRate {
    VK_VERTEX_INPUT_STEP_RATE_VERTEX                        = 0x00000000,
    VK_VERTEX_INPUT_STEP_RATE_INSTANCE                      = 0x00000001,
}

/// Vulkan format definitions
enum VkFormat {
    VK_FORMAT_UNDEFINED                                     = 0x00000000,
    VK_FORMAT_R4G4_UNORM                                    = 0x00000001,
    VK_FORMAT_R4G4_USCALED                                  = 0x00000002,
    VK_FORMAT_R4G4B4A4_UNORM                                = 0x00000003,
    VK_FORMAT_R4G4B4A4_USCALED                              = 0x00000004,
    VK_FORMAT_R5G6B5_UNORM                                  = 0x00000005,
    VK_FORMAT_R5G6B5_USCALED                                = 0x00000006,
    VK_FORMAT_R5G5B5A1_UNORM                                = 0x00000007,
    VK_FORMAT_R5G5B5A1_USCALED                              = 0x00000008,
    VK_FORMAT_R8_UNORM                                      = 0x00000009,
    VK_FORMAT_R8_SNORM                                      = 0x0000000A,
    VK_FORMAT_R8_USCALED                                    = 0x0000000B,
    VK_FORMAT_R8_SSCALED                                    = 0x0000000C,
    VK_FORMAT_R8_UINT                                       = 0x0000000D,
    VK_FORMAT_R8_SINT                                       = 0x0000000E,
    VK_FORMAT_R8_SRGB                                       = 0x0000000F,
    VK_FORMAT_R8G8_UNORM                                    = 0x00000010,
    VK_FORMAT_R8G8_SNORM                                    = 0x00000011,
    VK_FORMAT_R8G8_USCALED                                  = 0x00000012,
    VK_FORMAT_R8G8_SSCALED                                  = 0x00000013,
    VK_FORMAT_R8G8_UINT                                     = 0x00000014,
    VK_FORMAT_R8G8_SINT                                     = 0x00000015,
    VK_FORMAT_R8G8_SRGB                                     = 0x00000016,
    VK_FORMAT_R8G8B8_UNORM                                  = 0x00000017,
    VK_FORMAT_R8G8B8_SNORM                                  = 0x00000018,
    VK_FORMAT_R8G8B8_USCALED                                = 0x00000019,
    VK_FORMAT_R8G8B8_SSCALED                                = 0x0000001A,
    VK_FORMAT_R8G8B8_UINT                                   = 0x0000001B,
    VK_FORMAT_R8G8B8_SINT                                   = 0x0000001C,
    VK_FORMAT_R8G8B8_SRGB                                   = 0x0000001D,
    VK_FORMAT_R8G8B8A8_UNORM                                = 0x0000001E,
    VK_FORMAT_R8G8B8A8_SNORM                                = 0x0000001F,
    VK_FORMAT_R8G8B8A8_USCALED                              = 0x00000020,
    VK_FORMAT_R8G8B8A8_SSCALED                              = 0x00000021,
    VK_FORMAT_R8G8B8A8_UINT                                 = 0x00000022,
    VK_FORMAT_R8G8B8A8_SINT                                 = 0x00000023,
    VK_FORMAT_R8G8B8A8_SRGB                                 = 0x00000024,
    VK_FORMAT_R10G10B10A2_UNORM                             = 0x00000025,
    VK_FORMAT_R10G10B10A2_SNORM                             = 0x00000026,
    VK_FORMAT_R10G10B10A2_USCALED                           = 0x00000027,
    VK_FORMAT_R10G10B10A2_SSCALED                           = 0x00000028,
    VK_FORMAT_R10G10B10A2_UINT                              = 0x00000029,
    VK_FORMAT_R10G10B10A2_SINT                              = 0x0000002A,
    VK_FORMAT_R16_UNORM                                     = 0x0000002B,
    VK_FORMAT_R16_SNORM                                     = 0x0000002C,
    VK_FORMAT_R16_USCALED                                   = 0x0000002D,
    VK_FORMAT_R16_SSCALED                                   = 0x0000002E,
    VK_FORMAT_R16_UINT                                      = 0x0000002F,
    VK_FORMAT_R16_SINT                                      = 0x00000030,
    VK_FORMAT_R16_SFLOAT                                    = 0x00000031,
    VK_FORMAT_R16G16_UNORM                                  = 0x00000032,
    VK_FORMAT_R16G16_SNORM                                  = 0x00000033,
    VK_FORMAT_R16G16_USCALED                                = 0x00000034,
    VK_FORMAT_R16G16_SSCALED                                = 0x00000035,
    VK_FORMAT_R16G16_UINT                                   = 0x00000036,
    VK_FORMAT_R16G16_SINT                                   = 0x00000037,
    VK_FORMAT_R16G16_SFLOAT                                 = 0x00000038,
    VK_FORMAT_R16G16B16_UNORM                               = 0x00000039,
    VK_FORMAT_R16G16B16_SNORM                               = 0x0000003A,
    VK_FORMAT_R16G16B16_USCALED                             = 0x0000003B,
    VK_FORMAT_R16G16B16_SSCALED                             = 0x0000003C,
    VK_FORMAT_R16G16B16_UINT                                = 0x0000003D,
    VK_FORMAT_R16G16B16_SINT                                = 0x0000003E,
    VK_FORMAT_R16G16B16_SFLOAT                              = 0x0000003F,
    VK_FORMAT_R16G16B16A16_UNORM                            = 0x00000040,
    VK_FORMAT_R16G16B16A16_SNORM                            = 0x00000041,
    VK_FORMAT_R16G16B16A16_USCALED                          = 0x00000042,
    VK_FORMAT_R16G16B16A16_SSCALED                          = 0x00000043,
    VK_FORMAT_R16G16B16A16_UINT                             = 0x00000044,
    VK_FORMAT_R16G16B16A16_SINT                             = 0x00000045,
    VK_FORMAT_R16G16B16A16_SFLOAT                           = 0x00000046,
    VK_FORMAT_R32_UINT                                      = 0x00000047,
    VK_FORMAT_R32_SINT                                      = 0x00000048,
    VK_FORMAT_R32_SFLOAT                                    = 0x00000049,
    VK_FORMAT_R32G32_UINT                                   = 0x0000004A,
    VK_FORMAT_R32G32_SINT                                   = 0x0000004B,
    VK_FORMAT_R32G32_SFLOAT                                 = 0x0000004C,
    VK_FORMAT_R32G32B32_UINT                                = 0x0000004D,
    VK_FORMAT_R32G32B32_SINT                                = 0x0000004E,
    VK_FORMAT_R32G32B32_SFLOAT                              = 0x0000004F,
    VK_FORMAT_R32G32B32A32_UINT                             = 0x00000050,
    VK_FORMAT_R32G32B32A32_SINT                             = 0x00000051,
    VK_FORMAT_R32G32B32A32_SFLOAT                           = 0x00000052,
    VK_FORMAT_R64_SFLOAT                                    = 0x00000053,
    VK_FORMAT_R64G64_SFLOAT                                 = 0x00000054,
    VK_FORMAT_R64G64B64_SFLOAT                              = 0x00000055,
    VK_FORMAT_R64G64B64A64_SFLOAT                           = 0x00000056,
    VK_FORMAT_R11G11B10_UFLOAT                              = 0x00000057,
    VK_FORMAT_R9G9B9E5_UFLOAT                               = 0x00000058,
    VK_FORMAT_D16_UNORM                                     = 0x00000059,
    VK_FORMAT_D24_UNORM_X8                                  = 0x0000005A,
    VK_FORMAT_D32_SFLOAT                                    = 0x0000005B,
    VK_FORMAT_S8_UINT                                       = 0x0000005C,
    VK_FORMAT_D16_UNORM_S8_UINT                             = 0x0000005D,
    VK_FORMAT_D24_UNORM_S8_UINT                             = 0x0000005E,
    VK_FORMAT_D32_SFLOAT_S8_UINT                            = 0x0000005F,
    VK_FORMAT_BC1_RGB_UNORM                                 = 0x00000060,
    VK_FORMAT_BC1_RGB_SRGB                                  = 0x00000061,
    VK_FORMAT_BC1_RGBA_UNORM                                = 0x00000062,
    VK_FORMAT_BC1_RGBA_SRGB                                 = 0x00000063,
    VK_FORMAT_BC2_UNORM                                     = 0x00000064,
    VK_FORMAT_BC2_SRGB                                      = 0x00000065,
    VK_FORMAT_BC3_UNORM                                     = 0x00000066,
    VK_FORMAT_BC3_SRGB                                      = 0x00000067,
    VK_FORMAT_BC4_UNORM                                     = 0x00000068,
    VK_FORMAT_BC4_SNORM                                     = 0x00000069,
    VK_FORMAT_BC5_UNORM                                     = 0x0000006A,
    VK_FORMAT_BC5_SNORM                                     = 0x0000006B,
    VK_FORMAT_BC6H_UFLOAT                                   = 0x0000006C,
    VK_FORMAT_BC6H_SFLOAT                                   = 0x0000006D,
    VK_FORMAT_BC7_UNORM                                     = 0x0000006E,
    VK_FORMAT_BC7_SRGB                                      = 0x0000006F,
    VK_FORMAT_ETC2_R8G8B8_UNORM                             = 0x00000070,
    VK_FORMAT_ETC2_R8G8B8_SRGB                              = 0x00000071,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM                           = 0x00000072,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB                            = 0x00000073,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM                           = 0x00000074,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB                            = 0x00000075,
    VK_FORMAT_EAC_R11_UNORM                                 = 0x00000076,
    VK_FORMAT_EAC_R11_SNORM                                 = 0x00000077,
    VK_FORMAT_EAC_R11G11_UNORM                              = 0x00000078,
    VK_FORMAT_EAC_R11G11_SNORM                              = 0x00000079,
    VK_FORMAT_ASTC_4x4_UNORM                                = 0x0000007A,
    VK_FORMAT_ASTC_4x4_SRGB                                 = 0x0000007B,
    VK_FORMAT_ASTC_5x4_UNORM                                = 0x0000007C,
    VK_FORMAT_ASTC_5x4_SRGB                                 = 0x0000007D,
    VK_FORMAT_ASTC_5x5_UNORM                                = 0x0000007E,
    VK_FORMAT_ASTC_5x5_SRGB                                 = 0x0000007F,
    VK_FORMAT_ASTC_6x5_UNORM                                = 0x00000080,
    VK_FORMAT_ASTC_6x5_SRGB                                 = 0x00000081,
    VK_FORMAT_ASTC_6x6_UNORM                                = 0x00000082,
    VK_FORMAT_ASTC_6x6_SRGB                                 = 0x00000083,
    VK_FORMAT_ASTC_8x5_UNORM                                = 0x00000084,
    VK_FORMAT_ASTC_8x5_SRGB                                 = 0x00000085,
    VK_FORMAT_ASTC_8x6_UNORM                                = 0x00000086,
    VK_FORMAT_ASTC_8x6_SRGB                                 = 0x00000087,
    VK_FORMAT_ASTC_8x8_UNORM                                = 0x00000088,
    VK_FORMAT_ASTC_8x8_SRGB                                 = 0x00000089,
    VK_FORMAT_ASTC_10x5_UNORM                               = 0x0000008A,
    VK_FORMAT_ASTC_10x5_SRGB                                = 0x0000008B,
    VK_FORMAT_ASTC_10x6_UNORM                               = 0x0000008C,
    VK_FORMAT_ASTC_10x6_SRGB                                = 0x0000008D,
    VK_FORMAT_ASTC_10x8_UNORM                               = 0x0000008E,
    VK_FORMAT_ASTC_10x8_SRGB                                = 0x0000008F,
    VK_FORMAT_ASTC_10x10_UNORM                              = 0x00000090,
    VK_FORMAT_ASTC_10x10_SRGB                               = 0x00000091,
    VK_FORMAT_ASTC_12x10_UNORM                              = 0x00000092,
    VK_FORMAT_ASTC_12x10_SRGB                               = 0x00000093,
    VK_FORMAT_ASTC_12x12_UNORM                              = 0x00000094,
    VK_FORMAT_ASTC_12x12_SRGB                               = 0x00000095,
    VK_FORMAT_B4G4R4A4_UNORM                                = 0x00000096,
    VK_FORMAT_B5G5R5A1_UNORM                                = 0x00000097,
    VK_FORMAT_B5G6R5_UNORM                                  = 0x00000098,
    VK_FORMAT_B5G6R5_USCALED                                = 0x00000099,
    VK_FORMAT_B8G8R8_UNORM                                  = 0x0000009A,
    VK_FORMAT_B8G8R8_SNORM                                  = 0x0000009B,
    VK_FORMAT_B8G8R8_USCALED                                = 0x0000009C,
    VK_FORMAT_B8G8R8_SSCALED                                = 0x0000009D,
    VK_FORMAT_B8G8R8_UINT                                   = 0x0000009E,
    VK_FORMAT_B8G8R8_SINT                                   = 0x0000009F,
    VK_FORMAT_B8G8R8_SRGB                                   = 0x000000A0,
    VK_FORMAT_B8G8R8A8_UNORM                                = 0x000000A1,
    VK_FORMAT_B8G8R8A8_SNORM                                = 0x000000A2,
    VK_FORMAT_B8G8R8A8_USCALED                              = 0x000000A3,
    VK_FORMAT_B8G8R8A8_SSCALED                              = 0x000000A4,
    VK_FORMAT_B8G8R8A8_UINT                                 = 0x000000A5,
    VK_FORMAT_B8G8R8A8_SINT                                 = 0x000000A6,
    VK_FORMAT_B8G8R8A8_SRGB                                 = 0x000000A7,
    VK_FORMAT_B10G10R10A2_UNORM                             = 0x000000A8,
    VK_FORMAT_B10G10R10A2_SNORM                             = 0x000000A9,
    VK_FORMAT_B10G10R10A2_USCALED                           = 0x000000AA,
    VK_FORMAT_B10G10R10A2_SSCALED                           = 0x000000AB,
    VK_FORMAT_B10G10R10A2_UINT                              = 0x000000AC,
    VK_FORMAT_B10G10R10A2_SINT                              = 0x000000AD,
}

/// Shader stage enumerant
enum VkShaderStage {
    VK_SHADER_STAGE_VERTEX                                  = 0x00000000,
    VK_SHADER_STAGE_TESSELLATION_CONTROL                    = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION                 = 0x00000002,
    VK_SHADER_STAGE_GEOMETRY                                = 0x00000003,
    VK_SHADER_STAGE_FRAGMENT                                = 0x00000004,
    VK_SHADER_STAGE_COMPUTE                                 = 0x00000005,
}

/// Structure type enumerant
enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO                          = 0,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO                        = 1,
    VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO                         = 2,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO                    = 3,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO                 = 4,
    VK_STRUCTURE_TYPE_SHADER_CREATE_INFO                        = 5,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO              = 6,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO                       = 7,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO         = 8,
    VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO                    = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO                         = 10,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO                         = 11,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO                     = 12,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO                    = 13,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO         = 14,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO             = 15,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO   = 16,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO   = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO       = 19,
    VK_STRUCTURE_TYPE_PIPELINE_RASTER_STATE_CREATE_INFO         = 20,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO    = 21,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO    = 22,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO  = 23,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO                         = 24,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO                        = 25,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO                   = 26,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO                   = 27,
    VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO                     = 28,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO                   = 29,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER                            = 30,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER                     = 31,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER                      = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO               = 33,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET                      = 34,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET                       = 35,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO                      = 36,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO               = 37,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE                       = 38,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO                = 39,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION                    = 40,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION                       = 41,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY                        = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO                    = 43,
    VK_STRUCTURE_TYPE_CMD_POOL_CREATE_INFO                      = 44,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO                  = 45,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO        = 46,
}

enum VkRenderPassContents {
    VK_RENDER_PASS_CONTENTS_INLINE                          = 0x00000000,
    VK_RENDER_PASS_CONTENTS_SECONDARY_CMD_BUFFERS           = 0x00000001,
}

@lastUnused(-8)
/// Error and return codes
enum VkResult {
    // Return codes for successful operation execution (positive values)
    VK_SUCCESS                                              = 0x00000000,
    VK_UNSUPPORTED                                          = 0x00000001,
    VK_NOT_READY                                            = 0x00000002,
    VK_TIMEOUT                                              = 0x00000003,
    VK_EVENT_SET                                            = 0x00000004,
    VK_EVENT_RESET                                          = 0x00000005,
    VK_INCOMPLETE                                           = 0x00000006,

    // Error codes (negative values)
    VK_ERROR_OUT_OF_HOST_MEMORY                             = 0xFFFFFFFF,
    VK_ERROR_OUT_OF_DEVICE_MEMORY                           = 0xFFFFFFFE,
    VK_ERROR_INITIALIZATION_FAILED                          = 0xFFFFFFFD,
    VK_ERROR_DEVICE_LOST                                    = 0xFFFFFFFC,
    VK_ERROR_MEMORY_MAP_FAILED                              = 0xFFFFFFFB,
    VK_ERROR_LAYER_NOT_PRESENT                              = 0xFFFFFFFA,
    VK_ERROR_EXTENSION_NOT_PRESENT                          = 0xFFFFFFF9,
    VK_ERROR_INCOMPATIBLE_DRIVER                            = 0xFFFFFFF8,
}

enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT                               = 0x00000000,
    VK_DYNAMIC_STATE_SCISSOR                                = 0x00000001,
    VK_DYNAMIC_STATE_LINE_WIDTH                             = 0x00000002,
    VK_DYNAMIC_STATE_DEPTH_BIAS                             = 0x00000003,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS                        = 0x00000004,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS                           = 0x00000005,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK                   = 0x00000006,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK                     = 0x00000007,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE                      = 0x00000008,
}

//////////////////
//  Extensions  //
//////////////////

@extension("VK_EXT_KHR_swapchain")
enum VkSurfaceTransformKHR {
    VK_SURFACE_TRANSFORM_NONE_KHR                           = 0x00000000,
    VK_SURFACE_TRANSFORM_ROT90_KHR                          = 0x00000001,
    VK_SURFACE_TRANSFORM_ROT180_KHR                         = 0x00000002,
    VK_SURFACE_TRANSFORM_ROT270_KHR                         = 0x00000003,
    VK_SURFACE_TRANSFORM_HMIRROR_KHR                        = 0x00000004,
    VK_SURFACE_TRANSFORM_HMIRROR_ROT90_KHR                  = 0x00000005,
    VK_SURFACE_TRANSFORM_HMIRROR_ROT180_KHR                 = 0x00000006,
    VK_SURFACE_TRANSFORM_HMIRROR_ROT270_KHR                 = 0x00000007,
    VK_SURFACE_TRANSFORM_INHERIT_KHR                        = 0x00000008,
}

@extension("VK_EXT_KHR_swapchain")
enum VkPlatformKHR {
    VK_PLATFORM_WIN32_KHR                                   = 0x00000000,
    VK_PLATFORM_X11_KHR                                     = 0x00000001,
    VK_PLATFORM_XCB_KHR                                     = 0x00000002,
    VK_PLATFORM_ANDROID_KHR                                 = 0x00000003,
    VK_PLATFORM_WAYLAND_KHR                                 = 0x00000004,
    VK_PLATFORM_MIR_KHR                                     = 0x00000005,
}

@extension("VK_EXT_KHR_device_swapchain")
enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR                           = 0x00000000,
    VK_PRESENT_MODE_MAILBOX_KHR                             = 0x00000001,
    VK_PRESENT_MODE_FIFO_KHR                                = 0x00000002,
}

@extension("VK_EXT_KHR_device_swapchain")
enum VkColorSpaceKHR {
    VK_COLORSPACE_SRGB_NONLINEAR_KHR                        = 0x00000000,
}

/////////////////
//  Bitfields  //
/////////////////

/// Queue capabilities
bitfield VkQueueFlags {
    VK_QUEUE_GRAPHICS_BIT                                   = 0x00000001,    /// Queue supports graphics operations
    VK_QUEUE_COMPUTE_BIT                                    = 0x00000002,    /// Queue supports compute operations
    VK_QUEUE_DMA_BIT                                        = 0x00000004,    /// Queue supports DMA operations
    VK_QUEUE_SPARSE_MEMMGR_BIT                              = 0x00000008,    /// Queue supports sparse resource memory management operations
    VK_QUEUE_EXTENDED_BIT                                   = 0x40000000,    /// Extended queue
}

/// Memory properties passed into vkAllocMemory().
bitfield VkMemoryPropertyFlags {
    VK_MEMORY_PROPERTY_DEVICE_ONLY                          = 0x00000000,    /// If otherwise stated, then allocate memory on device
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT                     = 0x00000001,    /// Memory should be mappable by host
    VK_MEMORY_PROPERTY_HOST_NON_COHERENT_BIT                = 0x00000002,    /// Memory may not have i/o coherency so vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges must be used flush/invalidate host cache
                                                                             /// vkInvalidateMappedMemoryRanges must be used flush/invalidate host cache
    VK_MEMORY_PROPERTY_HOST_UNCACHED_BIT                    = 0x00000004,    /// Memory should not be cached by the host
    VK_MEMORY_PROPERTY_HOST_WRITE_COMBINED_BIT              = 0x00000008,    /// Memory should support host write combining
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT                 = 0x00000010,    /// Memory may be allocated by the driver when it is required
}

/// Memory heap flags
bitfield VkMemoryHeapFlags {
    VK_MEMORY_HEAP_HOST_LOCAL_BIT                           = 0x00000001,    /// If set, heap represents host memory
}

/// Memory output flags passed to resource transition commands
bitfield VkMemoryOutputFlags {
    VK_MEMORY_OUTPUT_HOST_WRITE_BIT                         = 0x00000001,    /// Controls output coherency of host writes
    VK_MEMORY_OUTPUT_SHADER_WRITE_BIT                       = 0x00000002,    /// Controls output coherency of generic shader writes
    VK_MEMORY_OUTPUT_COLOR_ATTACHMENT_BIT                   = 0x00000004,    /// Controls output coherency of color attachment writes
    VK_MEMORY_OUTPUT_DEPTH_STENCIL_ATTACHMENT_BIT           = 0x00000008,    /// Controls output coherency of depth/stencil attachment writes
    VK_MEMORY_OUTPUT_TRANSFER_BIT                           = 0x00000010,    /// Controls output coherency of transfer operations
}

/// Memory input flags passed to resource transition commands
bitfield VkMemoryInputFlags {
    VK_MEMORY_INPUT_HOST_READ_BIT                           = 0x00000001,    /// Controls input coherency of host reads
    VK_MEMORY_INPUT_INDIRECT_COMMAND_BIT                    = 0x00000002,    /// Controls input coherency of indirect command reads
    VK_MEMORY_INPUT_INDEX_FETCH_BIT                         = 0x00000004,    /// Controls input coherency of index fetches
    VK_MEMORY_INPUT_VERTEX_ATTRIBUTE_FETCH_BIT              = 0x00000008,    /// Controls input coherency of vertex attribute fetches
    VK_MEMORY_INPUT_UNIFORM_READ_BIT                        = 0x00000010,    /// Controls input coherency of uniform buffer reads
    VK_MEMORY_INPUT_SHADER_READ_BIT                         = 0x00000020,    /// Controls input coherency of generic shader reads
    VK_MEMORY_INPUT_COLOR_ATTACHMENT_BIT                    = 0x00000040,    /// Controls input coherency of color attachment reads
    VK_MEMORY_INPUT_DEPTH_STENCIL_ATTACHMENT_BIT            = 0x00000080,    /// Controls input coherency of depth/stencil attachment reads
    VK_MEMORY_INPUT_INPUT_ATTACHMENT_BIT                    = 0x00000100,    /// Controls input coherency of input attachment reads
    VK_MEMORY_INPUT_TRANSFER_BIT                            = 0x00000200,    /// Controls input coherency of transfer operations
}

/// Buffer usage flags
bitfield VkBufferUsageFlags {
    VK_BUFFER_USAGE_TRANSFER_SOURCE_BIT                     = 0x00000001,    /// Can be used as a source of transfer operations
    VK_BUFFER_USAGE_TRANSFER_DESTINATION_BIT                = 0x00000002,    /// Can be used as a destination of transfer operations
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT                = 0x00000004,    /// Can be used as TBO
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT                = 0x00000008,    /// Can be used as IBO
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT                      = 0x00000010,    /// Can be used as UBO
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT                      = 0x00000020,    /// Can be used as SSBO
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT                        = 0x00000040,    /// Can be used as source of fixed function index fetch (index buffer)
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT                       = 0x00000080,    /// Can be used as source of fixed function vertex fetch (VBO)
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT                     = 0x00000100,    /// Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
}

/// Buffer creation flags
bitfield VkBufferCreateFlags {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT                     = 0x00000001,    /// Buffer should support sparse backing
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT                   = 0x00000002,    /// Buffer should support sparse backing with partial residency
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT                     = 0x00000004,    /// Buffer should support constent data access to physical memory blocks mapped into multiple locations of sparse buffers
}

/// Shader stage flags
bitfield VkShaderStageFlags {
    VK_SHADER_STAGE_VERTEX_BIT                              = 0x00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT                = 0x00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT             = 0x00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT                            = 0x00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT                            = 0x00000010,
    VK_SHADER_STAGE_COMPUTE_BIT                             = 0x00000020,

    VK_SHADER_STAGE_ALL                                     = 0x7FFFFFFF,
}

/// Image usage flags
bitfield VkImageUsageFlags {
    VK_IMAGE_USAGE_TRANSFER_SOURCE_BIT                      = 0x00000001,    /// Can be used as a source of transfer operations
    VK_IMAGE_USAGE_TRANSFER_DESTINATION_BIT                 = 0x00000002,    /// Can be used as a destination of transfer operations
    VK_IMAGE_USAGE_SAMPLED_BIT                              = 0x00000004,    /// Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    VK_IMAGE_USAGE_STORAGE_BIT                              = 0x00000008,    /// Can be used as storage image (STORAGE_IMAGE descriptor type)
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT                     = 0x00000010,    /// Can be used as framebuffer color attachment
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT             = 0x00000020,    /// Can be used as framebuffer depth/stencil attachment
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT                 = 0x00000040,    /// Image data not needed outside of rendering
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT                     = 0x00000080,    /// Can be used as framebuffer input attachment
}

/// Image creation flags
bitfield VkImageCreateFlags {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT                      = 0x00000001,    /// Image should support sparse backing
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT                    = 0x00000002,    /// Image should support sparse backing with partial residency
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT                      = 0x00000004,    /// Image should support constent data access to physical memory blocks mapped into multiple locations of sparse images
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT                      = 0x00000008,    /// Allows image views to have different format than the base image
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT                     = 0x00000010,    /// Allows creating image views with cube type from the created image
}

/// Framebuffer attachment view creation flags
bitfield VkImageViewCreateFlags {
    VK_IMAGE_VIEW_CREATE_READ_ONLY_DEPTH_BIT                = 0x00000001,
    VK_IMAGE_VIEW_CREATE_READ_ONLY_STENCIL_BIT              = 0x00000002,
}

/// Pipeline creation flags
bitfield VkPipelineCreateFlags {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT             = 0x00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT                = 0x00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT                       = 0x00000004,
}

/// Channel flags
bitfield VkChannelFlags {
    VK_CHANNEL_R_BIT                                        = 0x00000001,
    VK_CHANNEL_G_BIT                                        = 0x00000002,
    VK_CHANNEL_B_BIT                                        = 0x00000004,
    VK_CHANNEL_A_BIT                                        = 0x00000008,
}

/// Fence creation flags
bitfield VkFenceCreateFlags {
    VK_FENCE_CREATE_SIGNALED_BIT                            = 0x00000001,
}

/// Semaphore creation flags
bitfield VkSemaphoreCreateFlags {
}

/// Format capability flags
bitfield VkFormatFeatureFlags {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT                     = 0x00000001,    /// Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT                     = 0x00000002,    /// Format can be used for storage images (STORAGE_IMAGE descriptor type)
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT              = 0x00000004,    /// Format supports atomic operations in case it's used for storage images
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT              = 0x00000008,    /// Format can be used for uniform texel buffers (TBOs)
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT              = 0x00000010,    /// Format can be used for storage texel buffers (IBOs)
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT       = 0x00000020,    /// Format supports atomic operations in case it's used for storage texel buffers
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT                     = 0x00000040,    /// Format can be used for vertex buffers (VBOs)
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT                  = 0x00000080,    /// Format can be used for color attachment images
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT            = 0x00000100,    /// Format supports blending in case it's used for color attachment images
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT          = 0x00000200,    /// Format can be used for depth/stencil attachment images
    VK_FORMAT_FEATURE_BLIT_SOURCE_BIT                       = 0x00000400,    /// Format can be used as the source image of blits with vkCmdBlitImage
    VK_FORMAT_FEATURE_BLIT_DESTINATION_BIT                  = 0x00000800,    /// Format can be used as the destination image of blits with vkCmdBlitImage
}

/// Query control flags
bitfield VkQueryControlFlags {
    VK_QUERY_CONTROL_CONSERVATIVE_BIT                       = 0x00000001,    /// Allow conservative results to be collected by the query
}

/// Query result flags
bitfield VkQueryResultFlags {
    VK_QUERY_RESULT_DEFAULT                                 = 0x00000000,   /// Results of the queries are immediately written to the destination buffer as 32-bit values
    VK_QUERY_RESULT_64_BIT                                  = 0x00000001,   /// Results of the queries are written to the destination buffer as 64-bit values
    VK_QUERY_RESULT_WAIT_BIT                                = 0x00000002,   /// Results of the queries are waited on before proceeding with the result copy
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT                   = 0x00000004,   /// Besides the results of the query, the availability of the results is also written
    VK_QUERY_RESULT_PARTIAL_BIT                             = 0x00000008,   /// Copy the partial results of the query even if the final results aren't available
}

/// Shader module creation flags
bitfield VkShaderModuleCreateFlags {
}

/// Shader creation flags
bitfield VkShaderCreateFlags {
}

/// Event creation flags
bitfield VkEventCreateFlags {
}

/// Command buffer creation flags
bitfield VkCmdBufferCreateFlags {
}

/// Command buffer optimization flags
bitfield VkCmdBufferOptimizeFlags {
    VK_CMD_BUFFER_OPTIMIZE_SMALL_BATCH_BIT                  = 0x00000001,
    VK_CMD_BUFFER_OPTIMIZE_PIPELINE_SWITCH_BIT              = 0x00000002,
    VK_CMD_BUFFER_OPTIMIZE_ONE_TIME_SUBMIT_BIT              = 0x00000004,
    VK_CMD_BUFFER_OPTIMIZE_DESCRIPTOR_SET_SWITCH_BIT        = 0x00000008,
    VK_CMD_BUFFER_OPTIMIZE_NO_SIMULTANEOUS_USE_BIT          = 0x00000010,  /// Only one call to the secondary command buffer will exist at any given time
}

/// Pipeline statistics flags
bitfield VkQueryPipelineStatisticFlags {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT                     = 0x00000001,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT                   = 0x00000002,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT                   = 0x00000004,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT                 = 0x00000008,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT                  = 0x00000010,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT                        = 0x00000020,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT                         = 0x00000040,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT                 = 0x00000080,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT         = 0x00000100,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT  = 0x00000200,  /// Optional
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT                  = 0x00000400,  /// Optional
}

/// Memory mapping flags
bitfield VkMemoryMapFlags {
}

/// Bitfield of image aspects
bitfield VkImageAspectFlags {
    VK_IMAGE_ASPECT_COLOR_BIT                               = 0x00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT                               = 0x00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT                             = 0x00000004,
    VK_IMAGE_ASPECT_METADATA_BIT                            = 0x00000008,
}

/// Sparse memory bind flags
bitfield VkSparseMemoryBindFlags {
    VK_SPARSE_MEMORY_BIND_REPLICATE_64KIB_BLOCK_BIT         = 0x00000001,  /// Replicate the first 64 KiB memory block to the entire bind rage
}

/// Sparse image memory requirements flags
bitfield VkSparseImageFormatFlags {
    VK_SPARSE_IMAGE_FMT_SINGLE_MIPTAIL_BIT                  = 0x00000001,  /// Image uses a single miptail region for all array slices
    VK_SPARSE_IMAGE_FMT_ALIGNED_MIP_SIZE_BIT                = 0x00000002,  /// Image requires mip levels to be an exact multiple of the sparse iamge block size for non-mip-tail levels.
    VK_SPARSE_IMAGE_FMT_NONSTD_BLOCK_SIZE_BIT               = 0x00000004,  /// Image uses a non-standard sparse block size
}

/// Pipeline stages
bitfield VkPipelineStageFlags {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT                       = 0x00000001,  /// Before subsequent commands are processed
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT                     = 0x00000002,  /// Draw/DispatchIndirect command fetch
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT                      = 0x00000004,  /// Vertex/index fetch
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT                     = 0x00000008,  /// Vertex shading
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT       = 0x00000010,  /// Tessellation control shading
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT    = 0x00000020,  /// Tessellation evaluation shading
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT                   = 0x00000040,  /// Geometry shading
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT                   = 0x00000080,  /// Fragment shading
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT              = 0x00000100,  /// Early fragment (depth/stencil) tests
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT               = 0x00000200,  /// Late fragment (depth/stencil) tests
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT           = 0x00000400,  /// Color attachment writes
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT                    = 0x00000800,  /// Compute shading
    VK_PIPELINE_STAGE_TRANSFER_BIT                          = 0x00001000,  /// Transfer/copy operations
    VK_PIPELINE_STAGE_HOST_BIT                              = 0x00002000,  /// Indicates host (CPU) is a source/sink of the dependency

    VK_PIPELINE_STAGE_ALL_GRAPHICS                          = 0x000007FF,  /// All stages of the graphics pipeline
    VK_PIPELINE_STAGE_ALL_GPU_COMMANDS                      = 0x00001FFF,  /// All graphics, compute, copy, and transition commands
}

/// Render pass attachment description flags
bitfield VkAttachmentDescriptionFlags {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT                 = 0x00000001,  /// The attachment may alias physical memory of another attachment in the same renderpass
}

/// Subpass description flags
bitfield VkSubpassDescriptionFlags {
    VK_SUBPASS_DESCRIPTION_NO_OVERDRAW_BIT                  = 0x00000001,
}

/// Command pool creation flags
bitfield VkCmdPoolCreateFlags {
    VK_CMD_POOL_CREATE_TRANSIENT_BIT                        = 0x00000001,  /// Command buffers have a short lifetime
    VK_CMD_POOL_CREATE_RESET_COMMAND_BUFFER_BIT             = 0x00000002,  /// Command buffers may release their memory individually
}

/// Command pool reset flags
bitfield VkCmdPoolResetFlags {
    VK_CMD_POOL_RESET_RELEASE_RESOURCES_BIT                 = 0x00000001,  /// Release resources owned by the pool
}

bitfield VkCmdBufferResetFlags {
    VK_CMD_BUFFER_RESET_RELEASE_RESOURCES_BIT               = 0x00000001,  /// Release resources owned by the buffer
}

bitfield VkSampleCountFlags {
    VK_SAMPLE_COUNT_1_BIT                                   = 0x00000001,
    VK_SAMPLE_COUNT_2_BIT                                   = 0x00000002,
    VK_SAMPLE_COUNT_4_BIT                                   = 0x00000004,
    VK_SAMPLE_COUNT_8_BIT                                   = 0x00000008,
    VK_SAMPLE_COUNT_16_BIT                                  = 0x00000010,
    VK_SAMPLE_COUNT_32_BIT                                  = 0x00000020,
    VK_SAMPLE_COUNT_64_BIT                                  = 0x00000040,
}

bitfield VkStencilFaceFlags {
    VK_STENCIL_FACE_NONE                                    = 0x00000000,   /// No faces
    VK_STENCIL_FACE_FRONT_BIT                               = 0x00000001,   /// Front face
    VK_STENCIL_FACE_BACK_BIT                                = 0x00000002,   /// Back face
}

//////////////////
//  Extensions  //
//////////////////

@extension("VK_EXT_KHR_swapchain")
bitfield VkSurfaceTransformFlagsKHR {
    VK_SURFACE_TRANSFORM_NONE_BIT_KHR                       = 0x00000001,
    VK_SURFACE_TRANSFORM_ROT90_BIT_KHR                      = 0x00000002,
    VK_SURFACE_TRANSFORM_ROT180_BIT_KHR                     = 0x00000004,
    VK_SURFACE_TRANSFORM_ROT270_BIT_KHR                     = 0x00000008,
    VK_SURFACE_TRANSFORM_HMIRROR_BIT_KHR                    = 0x00000010,
    VK_SURFACE_TRANSFORM_HMIRROR_ROT90_BIT_KHR              = 0x00000020,
    VK_SURFACE_TRANSFORM_HMIRROR_ROT180_BIT_KHR             = 0x00000040,
    VK_SURFACE_TRANSFORM_HMIRROR_ROT270_BIT_KHR             = 0x00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR                    = 0x00000100,
}

//////////////////
//  Structures  //
//////////////////

class VkOffset2D {
    s32                                         x
    s32                                         y
}

class VkOffset3D {
    s32                                         x
    s32                                         y
    s32                                         z
}

class VkExtent2D {
    s32                                         width
    s32                                         height
}

class VkExtent3D {
    s32                                         width
    s32                                         height
    s32                                         depth
}

class VkViewport {
    f32                                         originX
    f32                                         originY
    f32                                         width
    f32                                         height
    f32                                         minDepth
    f32                                         maxDepth
}

class VkRect2D {
    VkOffset2D                                  offset
    VkExtent2D                                  extent
}

class VkRect3D {
    VkOffset3D                                  offset
    VkExtent3D                                  extent
}

class VkChannelMapping {
    VkChannelSwizzle                            r
    VkChannelSwizzle                            g
    VkChannelSwizzle                            b
    VkChannelSwizzle                            a
}

class VkPhysicalDeviceProperties {
    u32                                         apiVersion
    u32                                         driverVersion
    u32                                         vendorId
    u32                                         deviceId
    VkPhysicalDeviceType                        deviceType
    char[VK_MAX_PHYSICAL_DEVICE_NAME]           deviceName
    u8[VK_UUID_LENGTH]                          pipelineCacheUUID
    VkPhysicalDeviceLimits                      limits
    VkPhysicalDeviceSparseProperties            sparseProperties
}

class VkExtensionProperties {
    char[VK_MAX_EXTENSION_NAME]                 extName            /// extension name
    u32                                         specVersion        /// version of the extension specification implemented
}

class VkLayerProperties {
    char[VK_MAX_EXTENSION_NAME]                 layerName          /// layer name
    u32                                         specVersion        /// version of the layer specification implemented
    u32                                         implVersion        /// build or release version of the layer's library
    char[VK_MAX_DESCRIPTION]                    description        /// Free-form description of the layer
}

class VkApplicationInfo {
    VkStructureType                             sType              /// Type of structure. Should be VK_STRUCTURE_TYPE_APPLICATION_INFO
    const void*                                 pNext              /// Next structure in chain
    const char*                                 pAppName
    u32                                         appVersion
    const char*                                 pEngineName
    u32                                         engineVersion
    u32                                         apiVersion
}

class VkAllocCallbacks {
    void*                                       pUserData
    PFN_vkAllocFunction                         pfnAlloc
    PFN_vkFreeFunction                          pfnFree
}

class VkDeviceQueueCreateInfo {
    VkStructureType                             sStype                    /// Should be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO
    const void*                                 pNext                     /// Pointer to next structure
    u32                                         queueFamilyIndex
    u32                                         queueCount
}

class VkDeviceCreateInfo {
    VkStructureType                             sType                      /// Should be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure
    u32                                         requestedQueueRecordCount
    const VkDeviceQueueCreateInfo*              pRequestedQueues
    u32                                         layerCount
    const char* const*                          ppEnabledLayerNames        /// Ordered list of layer names to be enabled
    u32                                         extensionCount
    const char* const*                          ppEnabledExtensionNames
    const VkPhysicalDeviceFeatures*             pEnabledFeatures
}

class VkInstanceCreateInfo {
    VkStructureType                             sType                      /// Should be VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure
    const VkApplicationInfo*                    pAppInfo
    const VkAllocCallbacks*                     pAllocCb
    u32                                         layerCount
    const char* const*                          ppEnabledLayerNames        /// Ordered list of layer names to be enabled
    u32                                         extensionCount
    const char* const*                          ppEnabledExtensionNames    /// Extension names to be enabled
}

class VkQueueFamilyProperties {
    VkQueueFlags                                queueFlags                 /// Queue flags
    u32                                         queueCount
    VkBool32                                    supportsTimestamps
}

class VkPhysicalDeviceMemoryProperties {
    u32                                         memoryTypeCount
    VkMemoryType[VK_MAX_MEMORY_TYPES]           memoryTypes
    u32                                         memoryHeapCount
    VkMemoryHeap[VK_MAX_MEMORY_HEAPS]           memoryHeaps
}

class VkMemoryAllocInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO
    const void*                                 pNext                      /// Pointer to next structure
    VkDeviceSize                                allocationSize             /// Size of memory allocation
    u32                                         memoryTypeIndex            /// Index of the of the memory type to allocate from
}

class VkMemoryRequirements {
    VkDeviceSize                                size                       /// Specified in bytes
    VkDeviceSize                                alignment                  /// Specified in bytes
    u32                                         memoryTypeBits             /// Bitfield of the allowed memory type indices into memoryTypes[] for this object
}

class VkSparseImageFormatProperties {
    VkImageAspect                               aspect
    VkExtent3D                                  imageGranularity
    VkSparseImageFormatFlags                    flags
}

class VkSparseImageMemoryRequirements {
    VkSparseImageFormatProperties               formatProps
    u32                                         imageMipTailStartLOD
    VkDeviceSize                                imageMipTailSize           /// Specified in bytes, must be a multiple of image block size / alignment
    VkDeviceSize                                imageMipTailOffset         /// Specified in bytes, must be a multiple of image block size / alignment
    VkDeviceSize                                imageMipTailStride         /// Specified in bytes, must be a multiple of image block size / alignment
}

class VkMemoryType {
    VkMemoryPropertyFlags                       propertyFlags              /// Memory properties of this memory type
    u32                                         heapIndex                  /// Index of the memory heap allocations of this memory type are taken from
}

class VkMemoryHeap {
    VkDeviceSize                                size                       /// Available memory in the heap
    VkMemoryHeapFlags                           flags                      /// Flags for the heap
}

class VkMappedMemoryRange {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE
    const void*                                 pNext                      /// Pointer to next structure
    VkDeviceMemory                              mem                        /// Mapped memory object
    VkDeviceSize                                offset                     /// Offset within the mapped memory the range starts from
    VkDeviceSize                                size                       /// Size of the range within the mapped memory
}

class VkFormatProperties {
    VkFormatFeatureFlags                        linearTilingFeatures       /// Format features in case of linear tiling
    VkFormatFeatureFlags                        optimalTilingFeatures      /// Format features in case of optimal tiling
    VkFormatFeatureFlags                        bufferFeatures             /// Format features supported by buffers
}

class VkImageFormatProperties {
    VkExtent3D                                  maxExtent                  /// max image dimensions for this resource type
    u32                                         maxMipLevels               /// max number of mipmap levels for this resource type
    u32                                         maxArraySize               /// max array size for this resource type
    VkSampleCountFlags                          sampleCounts               /// supported sample counts for this resource type
    VkDeviceSize                                maxResourceSize            /// max size (in bytes) of this resource type
}

class VkDescriptorBufferInfo {
    VkBuffer                                    buffer                     /// Buffer used for this descriptor when the descriptor is UNIFORM_BUFFER[_DYNAMIC]
    VkDeviceSize                                offset                     /// Base offset from buffer start in bytes to update in the descriptor set.
    VkDeviceSize                                range                      /// Size in bytes of the buffer resource for this descriptor update.
}

class VkDescriptorInfo {
    VkBufferView                                bufferView                 /// Buffer view to write to the descriptor (in case it's a buffer descriptor, otherwise should be VK_NULL_HANDLE)
    VkSampler                                   sampler                    /// Sampler to write to the descriptor (in case it's a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor, otherwise should be VK_NULL_HANDLE)
    VkImageView                                 imageView                  /// Image view to write to the descriptor (in case it's a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor, otherwise should be VK_NULL_HANDLE)
    VkImageLayout                               imageLayout                /// Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE)
    VkDescriptorBufferInfo                      bufferInfo                 /// Raw buffer, size and offset for UNIFORM_BUFFER[_DYNAMIC] or STORAGE_BUFFER[_DYNAMIC] descriptor types. Ignored otherwise.
}

class VkWriteDescriptorSet {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET
    const void*                                 pNext                      /// Pointer to next structure
    VkDescriptorSet                             destSet                    /// Destination descriptor set
    u32                                         destBinding                /// Binding within the destination descriptor set to write
    u32                                         destArrayElement           /// Array element within the destination binding to write
    u32                                         count                      /// Number of descriptors to write (determines the size of the array pointed by <pDescriptors>)
    VkDescriptorType                            descriptorType             /// Descriptor type to write (determines which fields of the array pointed by <pDescriptors> are going to be used)
    const VkDescriptorInfo*                     pDescriptors               /// Array of info structures describing the descriptors to write
}

class VkCopyDescriptorSet {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET
    const void*                                 pNext                      /// Pointer to next structure
    VkDescriptorSet                             srcSet                     /// Source descriptor set
    u32                                         srcBinding                 /// Binding within the source descriptor set to copy from
    u32                                         srcArrayElement            /// Array element within the source binding to copy from
    VkDescriptorSet                             destSet                    /// Destination descriptor set
    u32                                         destBinding                /// Binding within the destination descriptor set to copy to
    u32                                         destArrayElement           /// Array element within the destination binding to copy to
    u32                                         count                      /// Number of descriptors to copy
}

class VkBufferCreateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure.
    VkDeviceSize                                size                       /// Specified in bytes
    VkBufferUsageFlags                          usage                      /// Buffer usage flags
    VkBufferCreateFlags                         flags                      /// Buffer creation flags
    VkSharingMode                               sharingMode
    u32                                         queueFamilyCount
    const u32*                                  pQueueFamilyIndices
}

class VkBufferViewCreateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure.
    VkBuffer                                    buffer
    VkFormat                                    format                     /// Optionally specifies format of elements
    VkDeviceSize                                offset                     /// Specified in bytes
    VkDeviceSize                                range                      /// View size specified in bytes
}

class VkImageSubresource {
    VkImageAspect                               aspect
    u32                                         mipLevel
    u32                                         arrayLayer
}

class VkImageSubresourceRange {
    VkImageAspectFlags                          aspectMask
    u32                                         baseMipLevel
    u32                                         mipLevels
    u32                                         baseArrayLayer
    u32                                         arraySize
}

class VkMemoryBarrier {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_MEMORY_BARRIER
    const void*                                 pNext                      /// Pointer to next structure.
    VkMemoryOutputFlags                         outputMask                 /// Outputs the barrier should sync
    VkMemoryInputFlags                          inputMask                  /// Inputs the barrier should sync to
}

class VkBufferMemoryBarrier {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER
    const void*                                 pNext                      /// Pointer to next structure.
    VkMemoryOutputFlags                         outputMask                 /// Outputs the barrier should sync
    VkMemoryInputFlags                          inputMask                  /// Inputs the barrier should sync to
    u32                                         srcQueueFamilyIndex        /// Queue family to transition ownership from
    u32                                         destQueueFamilyIndex       /// Queue family to transition ownership to
    VkBuffer                                    buffer                     /// Buffer to sync
    VkDeviceSize                                offset                     /// Offset within the buffer to sync
    VkDeviceSize                                size                       /// Amount of bytes to sync
}

class VkImageMemoryBarrier {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER
    const void*                                 pNext                      /// Pointer to next structure.
    VkMemoryOutputFlags                         outputMask                 /// Outputs the barrier should sync
    VkMemoryInputFlags                          inputMask                  /// Inputs the barrier should sync to
    VkImageLayout                               oldLayout                  /// Current layout of the image
    VkImageLayout                               newLayout                  /// New layout to transition the image to
    u32                                         srcQueueFamilyIndex        /// Queue family to transition ownership from
    u32                                         destQueueFamilyIndex       /// Queue family to transition ownership to
    VkImage                                     image                      /// Image to sync
    VkImageSubresourceRange                     subresourceRange           /// Subresource range to sync
}

class VkImageCreateInfo {
    VkStructureType                             sType                      /// Must be VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO
    const void*                                 pNext                      /// Pointer to next structure.
    VkImageType                                 imageType
    VkFormat                                    format
    VkExtent3D                                  extent
    u32                                         mipLevels
    u32                                         arraySize
    u32                                         samples
    VkImageTiling                               tiling
    VkImageUsageFlags                           usage                      /// Image usage flags
    VkImageCreateFlags                          flags                      /// Image creation flags
    VkSharingMode                               sharingMode                /// Cross-queue-family sharing mode
    u32                                         queueFamilyCount           /// Number of queue families to share across
    const u32*                                  pQueueFamilyIndices        /// Array of queue family indices to share across
    VkImageLayout                               initialLayout              /// Initial image layout for all subresources
}

class VkSubresourceLayout {
    VkDeviceSize                                offset                 /// Specified in bytes
    VkDeviceSize                                size                   /// Specified in bytes
    VkDeviceSize                                rowPitch               /// Specified in bytes
    VkDeviceSize                                depthPitch             /// Specified in bytes
}

class VkImageViewCreateInfo {
    VkStructureType                             sType                  /// Must be VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO
    const void*                                 pNext                  /// Pointer to next structure
    VkImage                                     image
    VkImageViewType                             viewType
    VkFormat                                    format
    VkChannelMapping                            channels
    VkImageSubresourceRange                     subresourceRange
    VkImageViewCreateFlags                      flags
}

class VkBufferCopy {
    VkDeviceSize                                srcOffset              /// Specified in bytes
    VkDeviceSize                                destOffset             /// Specified in bytes
    VkDeviceSize                                copySize               /// Specified in bytes
}

class VkSparseMemoryBindInfo {
    VkDeviceSize                                rangeOffset           /// Specified in bytes
    VkDeviceSize                                rangeSize             /// Specified in bytes
    VkDeviceSize                                memOffset             /// Specified in bytes
    VkDeviceMemory                              mem
    VkSparseMemoryBindFlags                     flags
}

class VkSparseImageMemoryBindInfo {
    VkImageSubresource                          subresource
    VkOffset3D                                  offset
    VkExtent3D                                  extent
    VkDeviceSize                                memOffset             /// Specified in bytes
    VkDeviceMemory                              mem
    VkSparseMemoryBindFlags                     flags
}

class VkImageSubresourceCopy {
    VkImageAspect                               aspect
    u32                                         mipLevel
    u32                                         arrayLayer
    u32                                         arraySize
}

class VkImageCopy {
    VkImageSubresourceCopy                      srcSubresource
    VkOffset3D                                  srcOffset             /// Specified in pixels for both compressed and uncompressed images
    VkImageSubresourceCopy                      destSubresource
    VkOffset3D                                  destOffset            /// Specified in pixels for both compressed and uncompressed images
    VkExtent3D                                  extent                /// Specified in pixels for both compressed and uncompressed images
}

class VkImageBlit {
    VkImageSubresourceCopy                      srcSubresource
    VkOffset3D                                  srcOffset              /// Specified in pixels for both compressed and uncompressed images
    VkExtent3D                                  srcExtent              /// Specified in pixels for both compressed and uncompressed images
    VkImageSubresourceCopy                      destSubresource
    VkOffset3D                                  destOffset             /// Specified in pixels for both compressed and uncompressed images
    VkExtent3D                                  destExtent             /// Specified in pixels for both compressed and uncompressed images
}

class VkBufferImageCopy {
    VkDeviceSize                                bufferOffset           /// Specified in bytes
    u32                                         bufferRowLength        /// Specified in texels
    u32                                         bufferImageHeight
    VkImageSubresourceCopy                      imageSubresource
    VkOffset3D                                  imageOffset            /// Specified in pixels for both compressed and uncompressed images
    VkExtent3D                                  imageExtent            /// Specified in pixels for both compressed and uncompressed images
}

class VkImageResolve {
    VkImageSubresourceCopy                      srcSubresource
    VkOffset3D                                  srcOffset
    VkImageSubresourceCopy                      destSubresource
    VkOffset3D                                  destOffset
    VkExtent3D                                  extent
}

class VkShaderModuleCreateInfo {
    VkStructureType                             sType                  /// Must be VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO
    const void*                                 pNext                  /// Pointer to next structure
    platform.size_t                             codeSize               /// Specified in bytes
    const void*                                 pCode                  /// Binary code of size codeSize
    VkShaderModuleCreateFlags                   flags                  /// Reserved
}

class VkShaderCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_SHADER_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkShaderModule                              module             /// Module containing entry point
    const char*                                 pName              /// Null-terminated entry point name
    VkShaderCreateFlags                         flags              /// Reserved
    VkShaderStage                               stage
}

class VkDescriptorSetLayoutBinding {
    VkDescriptorType                            descriptorType     /// Type of the descriptors in this binding
    u32                                         arraySize          /// Number of descriptors in this binding
    VkShaderStageFlags                          stageFlags         /// Shader stages this binding is visible to
    const VkSampler*                            pImmutableSamplers /// Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains <count> number of elements)
}

class VkDescriptorSetLayoutCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    u32                                         count              /// Number of bindings in the descriptor set layout
    const VkDescriptorSetLayoutBinding*         pBinding           /// Array of descriptor set layout bindings
}

class VkDescriptorTypeCount {
    VkDescriptorType                            type
    u32                                         count
}

class VkDescriptorPoolCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkDescriptorPoolUsage                       poolUsage
    u32                                         maxSets
    u32                                         count
    const VkDescriptorTypeCount*                pTypeCount
}

class VkSpecializationMapEntry {
    u32                                         constantId         /// The SpecConstant ID specified in the BIL
    platform.size_t                             size               /// Size in bytes of the SpecConstant
    u32                                         offset             /// Offset of the value in the data block
}

class VkSpecializationInfo {
    u32                                         mapEntryCount      /// Number of entries in the map
    const VkSpecializationMapEntry*             pMap               /// Array of map entries
    platform.size_t                             dataSize           /// Size in bytes of pData
    const void*                                 pData              /// Pointer to SpecConstant data
}

class VkPipelineShaderStageCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkShaderStage                               stage
    VkShader                                    shader
    const VkSpecializationInfo*                 pSpecializationInfo
}

class VkComputePipelineCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkPipelineShaderStageCreateInfo             stage
    VkPipelineCreateFlags                       flags              /// Pipeline creation flags
    VkPipelineLayout                            layout             /// Interface layout of the pipeline
    VkPipeline                                  basePipelineHandle /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    s32                                         basePipelineIndex  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

class VkVertexInputBindingDescription {
    u32                                         binding        /// Vertex buffer binding id
    u32                                         strideInBytes  /// Distance between vertices in bytes (0 = no advancement)
    VkVertexInputStepRate                       stepRate       /// Rate at which binding is incremented
}

class VkVertexInputAttributeDescription {
    u32                                         location       /// location of the shader vertex attrib
    u32                                         binding        /// Vertex buffer binding id
    VkFormat                                    format         /// format of source data
    u32                                         offsetInBytes  /// Offset of first element in bytes from base of vertex
}

class VkPipelineVertexInputStateCreateInfo {
    VkStructureType                             sType          /// Should be VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO
    const void*                                 pNext          /// Pointer to next structure
    u32                                         bindingCount   /// number of bindings
    const VkVertexInputBindingDescription*      pVertexBindingDescriptions
    u32                                         attributeCount /// number of attributes
    const VkVertexInputAttributeDescription*    pVertexAttributeDescriptions
}

class VkPipelineInputAssemblyStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkPrimitiveTopology                         topology
    VkBool32                                    primitiveRestartEnable
}

class VkPipelineTessellationStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    u32                                         patchControlPoints
}

class VkPipelineViewportStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    u32                                         viewportCount
    const VkViewport*                           pViewports
    u32                                         scissorCount
    const VkRect2D*                             pScissors
}

class VkPipelineRasterStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_RASTER_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkBool32                                    depthClampEnable
    VkBool32                                    rasterizerDiscardEnable
    VkFillMode                                  fillMode                   /// optional (GL45)
    VkCullMode                                  cullMode
    VkFrontFace                                 frontFace
    VkBool32                                    depthBiasEnable
    f32                                         depthBias
    f32                                         depthBiasClamp
    f32                                         slopeScaledDepthBias
    f32                                         lineWidth
}

class VkPipelineMultisampleStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    u32                                         rasterSamples              /// Number of samples used for rasterization
    VkBool32                                    sampleShadingEnable        /// optional (GL45)
    f32                                         minSampleShading           /// optional (GL45)
    const VkSampleMask*                         pSampleMask
}

class VkPipelineColorBlendAttachmentState {
    VkBool32                                    blendEnable
    VkBlend                                     srcBlendColor
    VkBlend                                     destBlendColor
    VkBlendOp                                   blendOpColor
    VkBlend                                     srcBlendAlpha
    VkBlend                                     destBlendAlpha
    VkBlendOp                                   blendOpAlpha
    VkChannelFlags                              channelWriteMask
}

class VkPipelineColorBlendStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkBool32                                    alphaToCoverageEnable
    VkBool32                                    alphaToOneEnable
    VkBool32                                    logicOpEnable
    VkLogicOp                                   logicOp
    u32                                         attachmentCount    /// # of pAttachments
    const VkPipelineColorBlendAttachmentState*  pAttachments
    f32[4]                                      blendConst
}

class VkStencilOpState {
    VkStencilOp                                 stencilFailOp
    VkStencilOp                                 stencilPassOp
    VkStencilOp                                 stencilDepthFailOp
    VkCompareOp                                 stencilCompareOp
    u32                                         stencilCompareMask
    u32                                         stencilWriteMask
    u32                                         stencilReference
}

class VkPipelineDepthStencilStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkBool32                                    depthTestEnable
    VkBool32                                    depthWriteEnable
    VkCompareOp                                 depthCompareOp
    VkBool32                                    depthBoundsTestEnable  /// optional (depth_bounds_test)
    VkBool32                                    stencilTestEnable
    VkStencilOpState                            front
    VkStencilOpState                            back
    f32                                         minDepthBounds
    f32                                         maxDepthBounds
}

class VkPipelineDynamicStateCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    u32                                         dynamicStateCount
    const VkDynamicState*                       pDynamicStates
}

class VkGraphicsPipelineCreateInfo {
    VkStructureType                                 sType      /// Must be VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO
    const void*                                     pNext      /// Pointer to next structure
    u32                                             stageCount
    const VkPipelineShaderStageCreateInfo*          pStages    /// One entry for each active shader stage
    const VkPipelineVertexInputStateCreateInfo*     pVertexInputState
    const VkPipelineInputAssemblyStateCreateInfo*   pInputAssemblyState
    const VkPipelineTessellationStateCreateInfo*    pTessellationState
    const VkPipelineViewportStateCreateInfo*        pViewportState
    const VkPipelineRasterStateCreateInfo*          pRasterState
    const VkPipelineMultisampleStateCreateInfo*     pMultisampleState
    const VkPipelineDepthStencilStateCreateInfo*    pDepthStencilState
    const VkPipelineColorBlendStateCreateInfo*      pColorBlendState
    const VkPipelineDynamicStateCreateInfo*         pDynamicState
    VkPipelineCreateFlags                           flags              /// Pipeline creation flags
    VkPipelineLayout                                layout             /// Interface layout of the pipeline
    VkRenderPass                                    renderPass
    u32                                             subpass
    VkPipeline                                      basePipelineHandle /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    s32                                             basePipelineIndex  /// If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
}

class VkPipelineCacheCreateInfo {
    VkStructureType                             sType        /// Must be VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO
    const void*                                 pNext        /// Pointer to next structure
    platform.size_t                             initialSize  /// Size of initial data to populate cache, in bytes
    const void*                                 initialData  /// Initial data to populate cache
    platform.size_t                             maxSize      /// Maximum size cache can grow to, in bytes. If zero, then the cache may grow without bound.
}

class VkPushConstantRange {
    VkShaderStageFlags                          stageFlags   /// Which stages use the range
    u32                                         start        /// Start of the range, in bytes
    u32                                         length       /// Length of the range, in bytes
}

class VkPipelineLayoutCreateInfo {
    VkStructureType                             sType                   /// Must be VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO
    const void*                                 pNext                   /// Pointer to next structure
    u32                                         descriptorSetCount      /// Number of descriptor sets interfaced by the pipeline
    const VkDescriptorSetLayout*                pSetLayouts             /// Array of <setCount> number of descriptor set layout objects defining the layout of the
    u32                                         pushConstantRangeCount  /// Number of push-constant ranges used by the pipeline
    const VkPushConstantRange*                  pPushConstantRanges     /// Array of pushConstantRangeCount number of ranges used by various shader stages
}

class VkSamplerCreateInfo {
    VkStructureType                             sType          /// Must be VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO
    const void*                                 pNext          /// Pointer to next structure
    VkTexFilter                                 magFilter      /// Filter mode for magnification
    VkTexFilter                                 minFilter      /// Filter mode for minifiation
    VkTexMipmapMode                             mipMode        /// Mipmap selection mode
    VkTexAddressMode                            addressModeU
    VkTexAddressMode                            addressModeV
    VkTexAddressMode                            addressModeW
    f32                                         mipLodBias
    f32                                         maxAnisotropy
    VkBool32                                    compareEnable
    VkCompareOp                                 compareOp
    f32                                         minLod
    f32                                         maxLod
    VkBorderColor                               borderColor
    VkBool32                                    unnormalizedCoordinates
}

class VkCmdPoolCreateInfo {
    VkStructureType                             sType            /// Must be VK_STRUCTURE_TYPE_CMD_POOL_CREATE_INFO
    const void*                                 pNext            /// Pointer to next structure
    u32                                         queueFamilyIndex
    VkCmdPoolCreateFlags                        flags            /// Command pool creation flags
}

class VkCmdBufferCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkCmdPool                                   cmdPool
    VkCmdBufferLevel                            level
    VkCmdBufferCreateFlags                      flags      /// Command buffer creation flags
}

class VkCmdBufferBeginInfo {
    VkStructureType                             sType       /// Must be VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO
    const void*                                 pNext       /// Pointer to next structure
    VkCmdBufferOptimizeFlags                    flags       /// Command buffer optimization flags
    VkRenderPass                                renderPass  /// Render pass for secondary command buffers
    u32                                         subpass
    VkFramebuffer                               framebuffer /// Framebuffer for secondary command buffers
}

class VkRenderPassBeginInfo {
    VkStructureType                             sType       /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO
    const void*                                 pNext       /// Pointer to next structure
    VkRenderPass                                renderPass
    VkFramebuffer                               framebuffer
    VkRect2D                                    renderArea
    u32                                         clearValueCount
    const VkClearValue*                         pClearValues
}

@union
/// Union allowing specification of floating point, integer, or unsigned integer color data. Actual value selected is based on image/attachment being cleared.
class VkClearColorValue {
    f32[4]                                      float32
    s32[4]                                      int32
    u32[4]                                      uint32
}

class VkClearDepthStencilValue {
    f32                                         depth
    u32                                         stencil
}

@union
/// Union allowing specification of color, depth, and stencil color values. Actual value selected is based on attachment being cleared.
class VkClearValue {
    VkClearColorValue                           color
    VkClearDepthStencilValue                    depthStencil
}

class VkClearAttachment {
    VkImageAspectFlags                          aspectMask
    u32                                         colorAttachment
    VkClearValue                                clearValue
}

class VkAttachmentDescription {
    VkStructureType                             sType           /// Must be VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION
    const void*                                 pNext           /// Pointer to next structure
    VkFormat                                    format
    u32                                         samples
    VkAttachmentLoadOp                          loadOp          /// Load op for color or depth data
    VkAttachmentStoreOp                         storeOp         /// Store op for color or depth data
    VkAttachmentLoadOp                          stencilLoadOp   /// Load op for stencil data
    VkAttachmentStoreOp                         stencilStoreOp  /// Store op for stencil data
    VkImageLayout                               initialLayout
    VkImageLayout                               finalLayout
    VkAttachmentDescriptionFlags                flags
}

class VkAttachmentReference {
    u32                                         attachment
    VkImageLayout                               layout
}

class VkSubpassDescription {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_SUBPASS_DESCRIPTION
    const void*                                 pNext              /// Pointer to next structure
    VkPipelineBindPoint                         pipelineBindPoint  /// Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    VkSubpassDescriptionFlags                   flags
    u32                                         inputCount
    const VkAttachmentReference*                pInputAttachments
    u32                                         colorCount
    const VkAttachmentReference*                pColorAttachments
    const VkAttachmentReference*                pResolveAttachments
    VkAttachmentReference                       depthStencilAttachment
    u32                                         preserveCount
    const VkAttachmentReference*                pPreserveAttachments
}

class VkSubpassDependency {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_SUBPASS_DEPENDENCY
    const void*                                 pNext      /// Pointer to next structure
    u32                                         srcSubpass
    u32                                         destSubpass
    VkPipelineStageFlags                        srcStageMask
    VkPipelineStageFlags                        destStageMask
    VkMemoryOutputFlags                         outputMask
    VkMemoryInputFlags                          inputMask
    VkBool32                                    byRegion
}

class VkRenderPassCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    u32                                         attachmentCount
    const VkAttachmentDescription*              pAttachments
    u32                                         subpassCount
    const VkSubpassDescription*                 pSubpasses
    u32                                         dependencyCount
    const VkSubpassDependency*                  pDependencies
}

class VkEventCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_EVENT_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkEventCreateFlags                          flags      /// Event creation flags
}

class VkFenceCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_FENCE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkFenceCreateFlags                          flags      /// Fence creation flags
}

class VkPhysicalDeviceFeatures {
    VkBool32                                    robustBufferAccess                        /// out of bounds buffer accesses are well defined
    VkBool32                                    fullDrawIndexUint32                       /// full 32-bit range of indices for indexed draw calls
    VkBool32                                    imageCubeArray                            /// image views which are arrays of cube maps
    VkBool32                                    independentBlend                          /// blending operations are controlled per-attachment
    VkBool32                                    geometryShader                            /// geometry stage
    VkBool32                                    tessellationShader                        /// tessellation control and evaluation stage
    VkBool32                                    sampleRateShading                         /// per-sample shading and interpolation
    VkBool32                                    dualSourceBlend                           /// blend operations which take two sources
    VkBool32                                    logicOp                                   /// logic operations
    VkBool32                                    multiDrawIndirect                         /// multi draw indirect
    VkBool32                                    depthClamp                                /// depth clamping
    VkBool32                                    depthBiasClamp                            /// depth bias clamping
    VkBool32                                    fillModeNonSolid                          /// point and wireframe fill modes
    VkBool32                                    depthBounds                               /// depth bounds test
    VkBool32                                    wideLines                                 /// lines with width greater than 1
    VkBool32                                    largePoints                               /// points with size greater than 1
    VkBool32                                    textureCompressionETC2                    /// ETC texture compression formats
    VkBool32                                    textureCompressionASTC_LDR                /// ASTC LDR texture compression formats
    VkBool32                                    textureCompressionBC                      /// BC1-7 texture compressed formats
    VkBool32                                    occlusionQueryNonConservative             /// non-conservative (exact) occlusion queries
    VkBool32                                    pipelineStatisticsQuery                   /// pipeline statistics query
    VkBool32                                    vertexSideEffects                         /// storage buffers and images in vertex stage
    VkBool32                                    tessellationSideEffects                   /// storage buffers and images in tessellation stage
    VkBool32                                    geometrySideEffects                       /// storage buffers and images in geometry stage
    VkBool32                                    fragmentSideEffects                       /// storage buffers and images in fragment stage
    VkBool32                                    shaderTessellationPointSize               /// tessellation stage can export point size
    VkBool32                                    shaderGeometryPointSize                   /// geometry stage can export point size
    VkBool32                                    shaderImageGatherExtended                 /// texture gather with run-time values and independent offsets
    VkBool32                                    shaderStorageImageExtendedFormats         /// the extended set of formats can be used for storage images
    VkBool32                                    shaderStorageImageMultisample             /// multisample images can be used for storage images
    VkBool32                                    shaderUniformBufferArrayDynamicIndexing   /// arrays of uniform buffers can be accessed with dynamically uniform indices
    VkBool32                                    shaderSampledImageArrayDynamicIndexing    /// arrays of sampled images can be accessed with dynamically uniform indices
    VkBool32                                    shaderStorageBufferArrayDynamicIndexing   /// arrays of storage buffers can be accessed with dynamically uniform indices
    VkBool32                                    shaderStorageImageArrayDynamicIndexing    /// arrays of storage images can be accessed with dynamically uniform indices
    VkBool32                                    shaderClipDistance                        /// clip distance in shaders
    VkBool32                                    shaderCullDistance                        /// cull distance in shaders
    VkBool32                                    shaderFloat64                             /// 64-bit floats (doubles) in shaders
    VkBool32                                    shaderInt64                               /// 64-bit integers in shaders
    VkBool32                                    shaderInt16                               /// 16-bit integers in shaders
    VkBool32                                    shaderResourceResidency                   /// shader can use texture operations that return resource residency information (requires sparseNonResident support)
    VkBool32                                    shaderResourceMinLOD                      /// shader can use texture operations that specify minimum resource LOD
    VkBool32                                    alphaToOne                                /// The fragment alpha channel can be forced to maximum representable alpha value
    VkBool32                                    sparseBinding                             /// Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    VkBool32                                    sparseResidencyBuffer                     /// Sparse resources support: GPU can access partially resident buffers
    VkBool32                                    sparseResidencyImage2D                    /// Sparse resources support: GPU can access partially resident 2D (non-MSAA non-DepthStencil) images
    VkBool32                                    sparseResidencyImage3D                    /// Sparse resources support: GPU can access partially resident 3D images
    VkBool32                                    sparseResidency2Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    VkBool32                                    sparseResidency4Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    VkBool32                                    sparseResidency8Samples                   /// Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    VkBool32                                    sparseResidency16Samples                  /// Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    VkBool32                                    sparseResidencyAliased                    /// Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
}

class VkPhysicalDeviceLimits {
    /// resource maximum sizes
    u32                                         maxImageDimension1D                       /// max 1D image dimension
    u32                                         maxImageDimension2D                       /// max 2D image dimension
    u32                                         maxImageDimension3D                       /// max 3D image dimension
    u32                                         maxImageDimensionCube                     /// max cubemap image dimension
    u32                                         maxImageArrayLayers                       /// max layers for image arrays
    VkSampleCountFlags                          sampleCounts                              /// sample counts supported for all images supporting rendering and sampling
    u32                                         maxTexelBufferSize                        /// max texel buffer size (bytes)
    u32                                         maxUniformBufferSize                      /// max uniform buffer size (bytes)
    u32                                         maxStorageBufferSize                      /// max storage buffer size (bytes)
    u32                                         maxPushConstantsSize                      /// max size of the push constants pool (bytes)
    /// memory limits
    u32                                         maxMemoryAllocationCount                  /// max number of device memory allocations supported
    VkDeviceSize                                bufferImageGranularity                    /// Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    VkDeviceSize                                sparseAddressSpaceSize                    /// Total address space available for sparse allocations (bytes)
    /// descriptor set limits
    u32                                         maxBoundDescriptorSets                    /// max number of descriptors sets that can be bound to a pipeline
    u32                                         maxDescriptorSets                         /// max number of allocated descriptor sets
    u32                                         maxPerStageDescriptorSamplers             /// max num of samplers allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorUniformBuffers       /// max num of uniform buffers allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorStorageBuffers       /// max num of storage buffers allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorSampledImages        /// max num of sampled images allowed per-stage in a descriptor set
    u32                                         maxPerStageDescriptorStorageImages        /// max num of storage images allowed per-stage in a descriptor set
    u32                                         maxDescriptorSetSamplers                  /// max num of samplers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetUniformBuffers            /// max num of uniform buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetUniformBuffersDynamic     /// max num of dynamic uniform buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetStorageBuffers            /// max num of storage buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetStorageBuffersDynamic     /// max num of dynamic storage buffers allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetSampledImages             /// max num of sampled images allowed in all stages in a descriptor set
    u32                                         maxDescriptorSetStorageImages             /// max num of storage images allowed in all stages in a descriptor set
    /// vertex stage limits
    u32                                         maxVertexInputAttributes                  /// max num of vertex input attribute slots
    u32                                         maxVertexInputBindings                    /// max num of vertex input binding slots
    u32                                         maxVertexInputAttributeOffset             /// max vertex input attribute offset added to vertex buffer offset
    u32                                         maxVertexInputBindingStride               /// max vertex input binding stride
    u32                                         maxVertexOutputComponents                 /// max num of output components written by vertex shader
    /// tessellation control stage limits
    u32                                         maxTessellationGenLevel                         /// max level supported by tess primitive generator
    u32                                         maxTessellationPatchSize                        /// max patch size (vertices)
    u32                                         maxTessellationControlPerVertexInputComponents  /// max num of input components per-vertex in TCS
    u32                                         maxTessellationControlPerVertexOutputComponents /// max num of output components per-vertex in TCS
    u32                                         maxTessellationControlPerPatchOutputComponents  /// max num of output components per-patch in TCS
    u32                                         maxTessellationControlTotalOutputComponents     /// max total num of per-vertex and per-patch output components in TCS
    u32                                         maxTessellationEvaluationInputComponents        /// max num of input components per vertex in TES
    u32                                         maxTessellationEvaluationOutputComponents       /// max num of output components per vertex in TES
    /// geometry stage limits
    u32                                         maxGeometryShaderInvocations              /// max invocation count supported in geometry shader
    u32                                         maxGeometryInputComponents                /// max num of input components read in geometry stage
    u32                                         maxGeometryOutputComponents               /// max num of output components written in geometry stage
    u32                                         maxGeometryOutputVertices                 /// max num of vertices that can be emitted in geometry stage
    u32                                         maxGeometryTotalOutputComponents          /// max total num of components (all vertices) written in geometry stage
    /// fragment stage limits
    u32                                         maxFragmentInputComponents                /// max num of input compontents read in fragment stage
    u32                                         maxFragmentOutputBuffers                  /// max num of output buffers written in fragment stage
    u32                                         maxFragmentDualSourceBuffers              /// max num of output buffers written when using dual source blending
    u32                                         maxFragmentCombinedOutputResources        /// max total num of storage buffers, storage images and output buffers
    /// compute stage limits
    u32                                         maxComputeSharedMemorySize                /// max total storage size of work group local storage (bytes)
    u32[3]                                      maxComputeWorkGroupCount                  /// max num of compute work groups that may be dispatched by a single command (x,y,z)
    u32                                         maxComputeWorkGroupInvocations            /// max total compute invocations in a single local work group
    u32[3]                                      maxComputeWorkGroupSize                   /// max local size of a compute work group (x,y,z)

    u32                                         subPixelPrecisionBits                     /// num bits of subpixel precision in screen x and y
    u32                                         subTexelPrecisionBits                     /// num bits of subtexel precision
    u32                                         mipmapPrecisionBits                       /// num bits of mipmap precision

    u32                                         maxDrawIndexedIndexValue                  /// max index value for indexed draw calls (for 32-bit indices)
    u32                                         maxDrawIndirectInstanceCount              /// max instance count for indirect draw calls
    VkBool32                                    primitiveRestartForPatches                /// is primitive restart supported for PATCHES

    f32                                         maxSamplerLodBias                         /// max absolute sampler level of detail bias
    f32                                         maxSamplerAnisotropy                      /// max degree of sampler anisotropy

    u32                                         maxViewports                              /// max number of active viewports
    u32[2]                                      maxViewportDimensions                     /// max viewport dimensions (x,y)
    f32[2]                                      viewportBoundsRange                       /// viewport bounds range (min,max)
    u32                                         viewportSubPixelBits                      /// num bits of subpixel precision for viewport

    u32                                         minMemoryMapAlignment                     /// min required alignment of pointers returned by MapMemory (bytes)
    u32                                         minTexelBufferOffsetAlignment             /// min required alignment for texel buffer offsets (bytes)
    u32                                         minUniformBufferOffsetAlignment           /// min required alignment for uniform buffer sizes and offsets (bytes)
    u32                                         minStorageBufferOffsetAlignment           /// min required alignment for storage buffer offsets (bytes)

    u32                                         minTexelOffset                            /// min texel offset for OpTextureSampleOffset
    u32                                         maxTexelOffset                            /// max texel offset for OpTextureSampleOffset
    u32                                         minTexelGatherOffset                      /// min texel offset for OpTextureGatherOffset
    u32                                         maxTexelGatherOffset                      /// max texel offset for OpTextureGatherOffset
    f32                                         minInterpolationOffset                    /// furthest negative offset for interpolateAtOffset
    f32                                         maxInterpolationOffset                    /// furthest positive offset for interpolateAtOffset
    u32                                         subPixelInterpolationOffsetBits           /// num of subpixel bits for interpolateAtOffset

    u32                                         maxFramebufferWidth                       /// max width for a framebuffer
    u32                                         maxFramebufferHeight                      /// max height for a framebuffer
    u32                                         maxFramebufferLayers                      /// max layer count for a layered framebuffer
    u32                                         maxFramebufferColorSamples                /// max color sample count for a framebuffer
    u32                                         maxFramebufferDepthSamples                /// max depth sample count for a framebuffer
    u32                                         maxFramebufferStencilSamples              /// max stencil sample count for a framebuffer
    u32                                         maxColorAttachments                       /// max num of framebuffer color attachments

    u32                                         maxSampledImageColorSamples               /// max num of color samples for a non-integer sampled image
    u32                                         maxSampledImageDepthSamples               /// max num of depth/stencil samples for a sampled image
    u32                                         maxSampledImageIntegerSamples             /// max num of samples supported for an integer image
    u32                                         maxStorageImageSamples                    /// max num of samples for a storage image
    u32                                         maxSampleMaskWords                        /// max num of sample mask words

    u64                                         timestampFrequency                        /// 1/clock_tick_granularity for timestamp queries

    u32                                         maxClipDistances                          /// max number of clip distances
    u32                                         maxCullDistances                          /// max number of cull distances
    u32                                         maxCombinedClipAndCullDistances           /// max combined number of user clipping

    f32[2]                                      pointSizeRange                            /// range (min,max) of supported point sizes
    f32[2]                                      lineWidthRange                            /// range (min,max) of supported line widths
    f32                                         pointSizeGranularity                      /// granularity of supported point sizes
    f32                                         lineWidthGranularity                      /// granularity of supported line widths
}

class VkPhysicalDeviceSparseProperties {
    VkBool32                                    residencyStandard2DBlockShape             /// Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard block shapes (based on pixel format)
    VkBool32                                    residencyStandard2DMSBlockShape           /// Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard block shapes (based on pixel format)
    VkBool32                                    residencyStandard3DBlockShape             /// Sparse resources support: GPU will access all 3D sparse resources using the standard block shapes (based on pixel format)
    VkBool32                                    residencyAlignedMipSize                   /// Sparse resources support: Images with mip-level dimensions that are NOT a multiple of the block size will be placed in the mip tail
    VkBool32                                    residencyNonResident                      /// Sparse resources support: GPU can safely access non-resident regions of a resource, read values from read-write resources are undefined
    VkBool32                                    residencyNonResidentStrict                /// Sparse resources support: GPU can safely access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
}

class VkSemaphoreCreateInfo {
    VkStructureType                             sType      /// Must be VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO
    const void*                                 pNext      /// Pointer to next structure
    VkSemaphoreCreateFlags                      flags      /// Semaphore creation flags
}

class VkQueryPoolCreateInfo {
    VkStructureType                             sType              /// Must be VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO
    const void*                                 pNext              /// Pointer to next structure
    VkQueryType                                 queryType
    u32                                         slots
    VkQueryPipelineStatisticFlags               pipelineStatistics /// Optional
}

class VkFramebufferCreateInfo {
    VkStructureType                             sType  /// Must be VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO
    const void*                                 pNext  /// Pointer to next structure
    VkRenderPass                                renderPass
    u32                                         attachmentCount
    const VkImageView*                          pAttachments
    u32                                         width
    u32                                         height
    u32                                         layers
}

class VkDrawIndirectCmd {
    u32                                         vertexCount
    u32                                         instanceCount
    u32                                         firstVertex
    u32                                         firstInstance
}

class VkDrawIndexedIndirectCmd {
    u32                                         indexCount
    u32                                         instanceCount
    u32                                         firstIndex
    s32                                         vertexOffset
    u32                                         firstInstance
}

class VkDispatchIndirectCmd {
    u32                                         x
    u32                                         y
    u32                                         z
}

//////////////////
//  Extensions  //
//////////////////

@extension("VK_EXT_KHR_device_swapchain")
class VkSurfacePropertiesKHR {
    u32                                     minImageCount
    u32                                     maxImageCount
    VkExtent2D                              currentExtent
    VkExtent2D                              minImageExtent
    VkExtent2D                              maxImageExtent
    VkSurfaceTransformFlagsKHR              supportedTransforms
    VkSurfaceTransformKHR                   currentTransform
    u32                                     maxImageArraySize
    VkImageUsageFlags                       supportedUsageFlags
}

@extension("VK_EXT_KHR_device_swapchain")
class VkSurfaceFormatKHR {
    VkFormat                                format
    VkColorSpaceKHR                         colorSpace
}

@extension("VK_EXT_KHR_device_swapchain")
class VkSwapchainCreateInfoKHR {
    VkStructureType                          sType
    const void*                              pNext
    const VkSurfaceDescriptionKHR*           pSurfaceDescription
    u32                                      minImageCount
    VkFormat                                 imageFormat
    VkColorSpaceKHR                          imageColorSpace
    VkExtent2D                               imageExtent
    VkImageUsageFlags                        imageUsageFlags
    VkSurfaceTransformKHR                    preTransform
    u32                                      imageArraySize
    VkSharingMode                            sharingMode
    u32                                      queueFamilyCount
    const u32*                               pQueueFamilyIndices
    VkPresentModeKHR                         presentMode
    VkSwapchainKHR                           oldSwapchain
    VkBool32                                 clipped
}

@extension("VK_EXT_KHR_device_swapchain")
class VkPresentInfoKHR {
    VkStructureType                          sType
    const void*                              pNext
    u32                                      swapchainCount
    const VkSwapchainKHR*                    swapchains
    const u32*                               imageIndices
}

@extension("VK_EXT_KHR_swapchain")
class VkSurfaceDescriptionKHR {
    VkStructureType                          sType
    const void*                              pNext
}

@extension("VK_EXT_KHR_swapchain")
class VkSurfaceDescriptionWindowKHR {
    VkStructureType                         sType
    const void*                             pNext
    VkPlatformKHR                           platform
    void*                                   pPlatformHandle
    void*                                   pPlatformWindow
}

////////////////
//  Commands  //
////////////////

// Function pointers. TODO: add support for function pointers.

@external type void* PFN_vkVoidFunction
@pfn cmd void vkVoidFunction() {
}

@external type void* PFN_vkAllocFunction
@pfn cmd void* vkAllocFunction(
        void*                                       pUserData,
        platform.size_t                             size,
        platform.size_t                             alignment,
        VkSystemAllocType                           allocType) {
    return ?
}

@external type void* PFN_vkFreeFunction
@pfn cmd void vkFreeFunction(
        void*                                       pUserData,
        void*                                       pMem) {
}


// Global functions

@threadSafety("system")
cmd VkResult vkCreateInstance(
        const VkInstanceCreateInfo*                 pCreateInfo,
        VkInstance*                                 pInstance) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO)

    instance := ?
    pInstance[0] = instance
    State.Instances[instance] = new!InstanceObject()

    layers := pCreateInfo.ppEnabledLayerNames[0:pCreateInfo.layerCount]
    extensions := pCreateInfo.ppEnabledExtensionNames[0:pCreateInfo.extensionCount]

    return ?
}

@threadSafety("system")
cmd void vkDestroyInstance(
        VkInstance                                  instance) {
    instanceObject := GetInstance(instance)

    State.Instances[instance] = null
}

@threadSafety("system")
cmd VkResult vkEnumeratePhysicalDevices(
        VkInstance                                  instance,
        u32*                                        pPhysicalDeviceCount,
        VkPhysicalDevice*                           pPhysicalDevices) {
    instanceObject := GetInstance(instance)

    physicalDeviceCount := as!u32(?)
    pPhysicalDeviceCount[0] = physicalDeviceCount
    physicalDevices := pPhysicalDevices[0:physicalDeviceCount]

    for i in (0 .. physicalDeviceCount) {
        physicalDevice := ?
        physicalDevices[i] = physicalDevice
        if !(physicalDevice in State.PhysicalDevices) {
            State.PhysicalDevices[physicalDevice] = new!PhysicalDeviceObject(instance: instance)
        }
    }

    return ?
}

cmd PFN_vkVoidFunction vkGetDeviceProcAddr(
        VkDevice                                    device,
        const char*                                 pName) {
    if device != NULL_HANDLE {
        device := GetDevice(device)
    }

    return ?
}

cmd PFN_vkVoidFunction vkGetInstanceProcAddr(
        VkInstance                                  instance,
        const char*                                 pName) {
    if instance != NULL_HANDLE {
        instanceObject := GetInstance(instance)
    }

    return ?
}

cmd VkResult vkGetPhysicalDeviceProperties(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceProperties*                 pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    properties := ?
    pProperties[0] = properties

    return ?
}

cmd VkResult vkGetPhysicalDeviceQueueFamilyProperties(
        VkPhysicalDevice                            physicalDevice,
        u32*                                        pCount,
        VkQueueFamilyProperties*                    pQueueFamilyProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    // TODO: Figure out how to express fetch-count-or-properties
    // This version fails 'apic validate' with 'fence not allowed in
    // *semantic.Branch'. Other attempts have failed with the same or other
    // errors.
    // if pQueueFamilyProperties != null {
    //     queuesProperties := pQueueFamilyProperties[0:pCount[0]]
    //     for i in (0 .. pCount[0]) {
    //         queueProperties := as!VkQueueFamilyProperties(?)
    //         queuesProperties[i] = queueProperties
    //    }
    // } else {
    //     count := ?
    //     pCount[0] = count
    // }
    return ?
}

cmd VkResult vkGetPhysicalDeviceMemoryProperties(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceMemoryProperties*           pMemoryProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    memoryProperties := ?
    pMemoryProperties[0] = memoryProperties

    return ?
}

cmd VkResult vkGetPhysicalDeviceFeatures(
        VkPhysicalDevice                            physicalDevice,
        VkPhysicalDeviceFeatures*                   pFeatures) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    features := ?
    pFeatures[0] = features

    return ?
}

cmd VkResult vkGetPhysicalDeviceFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkFormatProperties*                         pFormatProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    formatProperties := ?
    pFormatProperties[0] = formatProperties

    return ?
}

cmd VkResult vkGetPhysicalDeviceImageFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        VkImageTiling                               tiling,
        VkImageUsageFlags                           usage,
        VkImageCreateFlags                          flags,
        VkImageFormatProperties*                    pImageFormatProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    imageFormatProperties := ?
    pImageFormatProperties[0] = imageFormatProperties

    return ?
}


// Device functions

@threadSafety("system")
cmd VkResult vkCreateDevice(
        VkPhysicalDevice                            physicalDevice,
        const VkDeviceCreateInfo*                   pCreateInfo,
        VkDevice*                                   pDevice) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO)
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    device := ?
    pDevice[0] = device
    State.Devices[device] = new!DeviceObject(physicalDevice: physicalDevice)

    return ?
}

@threadSafety("system")
cmd void vkDestroyDevice(
        VkDevice                                    device) {
    deviceObject := GetDevice(device)

    State.Devices[device] = null
}


// Extension discovery functions

cmd VkResult vkEnumerateInstanceLayerProperties(
        u32*                                        pCount,
        VkLayerProperties*                          pProperties) {
    count := as!u32(?)
    pCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}

cmd VkResult vkEnumerateInstanceExtensionProperties(
        const char*                                 pLayerName,
        u32*                                        pCount,
        VkExtensionProperties*                      pProperties) {
    count := as!u32(?)
    pCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}

cmd VkResult vkEnumerateDeviceLayerProperties(
        VkPhysicalDevice                            physicalDevice,
        u32*                                        pCount,
        VkLayerProperties*                          pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)
    count := as!u32(?)
    pCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}

cmd VkResult vkEnumerateDeviceExtensionProperties(
        VkPhysicalDevice                            physicalDevice,
        const char*                                 pLayerName,
        u32*                                        pCount,
        VkExtensionProperties*                      pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    count := as!u32(?)
    pCount[0] = count

    properties := pProperties[0:count]
    for i in (0 .. count) {
        property := ?
        properties[i] = property
    }

    return ?
}


// Queue functions

@threadSafety("system")
cmd VkResult vkGetDeviceQueue(
        VkDevice                                    device,
        u32                                         queueFamilyIndex,
        u32                                         queueIndex,
        VkQueue*                                    pQueue) {
    deviceObject := GetDevice(device)

    queue := ?
    pQueue[0] = queue

    if !(queue in State.Queues) {
        State.Queues[queue] = new!QueueObject(device: device)
    }

    return ?
}

@threadSafety("app")
cmd VkResult vkQueueSubmit(
        VkQueue                                     queue,
        u32                                         cmdBufferCount,
        const VkCmdBuffer*                          pCmdBuffers,
        VkFence                                     fence) {
    queueObject := GetQueue(queue)

    if fence != NULL_HANDLE {
        fenceObject := GetFence(fence)
        assert(fenceObject.device == queueObject.device)
    }

    cmdBuffers := pCmdBuffers[0:cmdBufferCount]
    for i in (0 .. cmdBufferCount) {
        cmdBuffer := cmdBuffers[i]
        cmdBufferObject := GetCmdBuffer(cmdBuffer)
        assert(cmdBufferObject.device == queueObject.device)

        validate("QueueCheck", cmdBufferObject.queueFlags in queueObject.flags,
            "vkQueueSubmit: enqueued cmdBuffer requires missing queue capabilities.")
    }

    return ?
}

@threadSafety("system")
cmd VkResult vkQueueWaitIdle(
        VkQueue                                     queue) {
    queueObject := GetQueue(queue)

    return ?
}

@threadSafety("system")
cmd VkResult vkDeviceWaitIdle(
        VkDevice                                    device) {
    deviceObject := GetDevice(device)

    return ?
}


// Memory functions

@threadSafety("system")
cmd VkResult vkAllocMemory(
        VkDevice                                    device,
        const VkMemoryAllocInfo*                    pAllocInfo,
        VkDeviceMemory*                             pMem) {
    assert(pAllocInfo.sType == VK_STRUCTURE_TYPE_MEMORY_ALLOC_INFO)
    deviceObject := GetDevice(device)

    mem := ?
    pMem[0] = mem
    State.DeviceMemories[mem] = new!DeviceMemoryObject(
        device: device,
        allocationSize: pAllocInfo[0].allocationSize)

    return ?
}

@threadSafety("system")
cmd void vkFreeMemory(
        VkDevice                                    device,
        VkDeviceMemory                              mem) {
    deviceObject := GetDevice(device)
    memObject := GetDeviceMemory(mem)
    assert(memObject.device == device)

    // Check that no objects are still bound before freeing.
    validate("MemoryCheck", len(memObject.boundObjects) == 0,
        "vkFreeMemory: objects still bound")
    validate("MemoryCheck", len(memObject.boundCommandBuffers) == 0,
        "vkFreeMemory: cmdBuffers still bound")
    State.DeviceMemories[mem] = null
}

@threadSafety("app")
cmd VkResult vkMapMemory(
        VkDevice                                    device,
        VkDeviceMemory                              mem,
        VkDeviceSize                                offset,
        VkDeviceSize                                size,
        VkMemoryMapFlags                            flags,
        void**                                      ppData) {
    deviceObject := GetDevice(device)
    memObject := GetDeviceMemory(mem)
    assert(memObject.device == device)

    assert(flags == as!VkMemoryMapFlags(0))
    assert((offset + size) <= memObject.allocationSize)

    return ?
}

@threadSafety("app")
cmd void vkUnmapMemory(
        VkDevice                                    device,
        VkDeviceMemory                              mem) {
    deviceObject := GetDevice(device)
    memObject := GetDeviceMemory(mem)
    assert(memObject.device == device)
}

cmd VkResult vkFlushMappedMemoryRanges(
        VkDevice                                    device,
        u32                                         memRangeCount
        const VkMappedMemoryRange*                  pMemRanges) {
    deviceObject := GetDevice(device)

    memRanges := pMemRanges[0:memRangeCount]
    for i in (0 .. memRangeCount) {
        memRange := memRanges[i]
        memObject := GetDeviceMemory(memRange.mem)
        assert(memObject.device == device)
        assert((memRange.offset + memRange.size) <= memObject.allocationSize)
    }

    return ?
}

cmd VkResult vkInvalidateMappedMemoryRanges(
        VkDevice                                    device,
        u32                                         memRangeCount,
        const VkMappedMemoryRange*                  pMemRanges) {
    deviceObject := GetDevice(device)

    memRanges := pMemRanges[0:memRangeCount]
    for i in (0 .. memRangeCount) {
        memRange := memRanges[i]
        memObject := GetDeviceMemory(memRange.mem)
        assert(memObject.device == device)
        assert((memRange.offset + memRange.size) <= memObject.allocationSize)
    }

    return ?
}


// Memory management API functions

cmd VkResult vkGetDeviceMemoryCommitment(
        VkDevice                                    device,
        VkDeviceMemory                              memory,
        VkDeviceSize*                               pCommittedMemoryInBytes) {
    deviceObject := GetDevice(device)

    if memory != NULL_HANDLE {
        memoryObject := GetDeviceMemory(memory)
        assert(memoryObject.device == device)
    }

    committedMemoryInBytes := ?
    pCommittedMemoryInBytes[0] = committedMemoryInBytes

    return ?
}

cmd VkResult vkGetBufferMemoryRequirements(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkMemoryRequirements*                       pMemoryRequirements) {
    deviceObject := GetDevice(device)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == device)

    return ?
}

cmd VkResult vkBindBufferMemory(
        VkDevice                                    device,
        VkBuffer                                    buffer,
        VkDeviceMemory                              mem,
        VkDeviceSize                                memOffset) {
    deviceObject := GetDevice(device)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == device)

    // Unbind buffer from previous memory object, if not VK_NULL_HANDLE.
    if bufferObject.mem != NULL_HANDLE {
        memObject := GetDeviceMemory(bufferObject.mem)
        memObject.boundObjects[as!u64(buffer)] = null
    }

    // Bind buffer to given memory object, if not VK_NULL_HANDLE.
    if mem != NULL_HANDLE {
        memObject := GetDeviceMemory(mem)
        assert(memObject.device == device)
        memObject.boundObjects[as!u64(buffer)] = memOffset
    }
    bufferObject.mem = mem
    bufferObject.memOffset = memOffset

    return ?
}

cmd VkResult vkGetImageMemoryRequirements(
        VkDevice                                    device,
        VkImage                                     image,
        VkMemoryRequirements*                       pMemoryRequirements) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    return ?
}

cmd VkResult vkBindImageMemory(
        VkDevice                                    device,
        VkImage                                     image,
        VkDeviceMemory                              mem,
        VkDeviceSize                                memOffset) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    // Unbind image from previous memory object, if not VK_NULL_HANDLE.
    if imageObject.mem != NULL_HANDLE {
        memObject := GetDeviceMemory(imageObject.mem)
        memObject.boundObjects[as!u64(image)] = null
    }

    // Bind image to given memory object, if not VK_NULL_HANDLE.
    if mem != NULL_HANDLE {
        memObject := GetDeviceMemory(mem)
        assert(memObject.device == device)
        memObject.boundObjects[as!u64(image)] = memOffset
    }
    imageObject.mem = mem
    imageObject.memOffset = memOffset

    return ?
}

cmd VkResult vkGetImageSparseMemoryRequirements(
        VkDevice                                    device,
        VkImage                                     image,
        u32*                                        pNumRequirements,
        VkSparseImageMemoryRequirements*            pSparseMemoryRequirements) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    return ?
}

cmd VkResult vkGetPhysicalDeviceSparseImageFormatProperties(
        VkPhysicalDevice                            physicalDevice,
        VkFormat                                    format,
        VkImageType                                 type,
        u32                                         samples,
        VkImageUsageFlags                           usage,
        VkImageTiling                               tiling,
        u32*                                        pNumProperties,
        VkSparseImageFormatProperties*              pProperties) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    return ?
}

cmd VkResult vkQueueBindSparseBufferMemory(
        VkQueue                                     queue,
        VkBuffer                                    buffer,
        u32                                         numBindings,
        const VkSparseMemoryBindInfo*               pBindInfo) {
    queueObject := GetQueue(queue)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == queueObject.device)

    return ?
}

cmd VkResult vkQueueBindSparseImageOpaqueMemory(
        VkQueue                                     queue,
        VkImage                                     image,
        u32                                         numBindings,
        const VkSparseMemoryBindInfo*               pBindInfo) {
    queueObject := GetQueue(queue)
    imageObject := GetImage(image)
    assert(imageObject.device == queueObject.device)

    return ?
}


cmd VkResult vkQueueBindSparseImageMemory(
        VkQueue                                     queue,
        VkImage                                     image,
        u32                                         numBindings,
        const VkSparseImageMemoryBindInfo*          pBindInfo) {
    queueObject := GetQueue(queue)
    imageObject := GetImage(image)

    return ?
}


// Fence functions

@threadSafety("system")
cmd VkResult vkCreateFence(
        VkDevice                                    device,
        const VkFenceCreateInfo*                    pCreateInfo,
        VkFence*                                    pFence) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_FENCE_CREATE_INFO)
    deviceObject := GetDevice(device)

    fence := ?
    pFence[0] = fence
    State.Fences[fence] = new!FenceObject(
        device: device, signaled: (pCreateInfo.flags == VK_FENCE_CREATE_SIGNALED_BIT))

    return ?
}

@threadSafety("system")
cmd void vkDestroyFence(
        VkDevice                                    device,
        VkFence                                     fence) {
    deviceObject := GetDevice(device)
    fenceObject := GetFence(fence)
    assert(fenceObject.device == device)

    State.Fences[fence] = null
}

@threadSafety("system")
cmd VkResult vkResetFences(
        VkDevice                                    device,
        u32                                         fenceCount,
        const VkFence*                              pFences) {
    deviceObject := GetDevice(device)

    fences := pFences[0:fenceCount]
    for i in (0 .. fenceCount) {
        fence := fences[i]
        fenceObject := GetFence(fence)
        assert(fenceObject.device == device)
        fenceObject.signaled = false
    }

    return ?
}

@threadSafety("system")
cmd VkResult vkGetFenceStatus(
        VkDevice                                    device,
        VkFence                                     fence) {
    deviceObject := GetDevice(device)
    fenceObject := GetFence(fence)
    assert(fenceObject.device == device)

    return ?
}

@threadSafety("system")
cmd VkResult vkWaitForFences(
        VkDevice                                    device,
        u32                                         fenceCount,
        const VkFence*                              pFences,
        VkBool32                                    waitAll,
        u64                                         timeout) {  /// timeout in nanoseconds
    deviceObject := GetDevice(device)

    fences := pFences[0:fenceCount]
    for i in (0 .. fenceCount) {
        fence := fences[i]
        fenceObject := GetFence(fence)
        assert(fenceObject.device == device)
    }

    return ?
}


// Queue semaphore functions

@threadSafety("system")
cmd VkResult vkCreateSemaphore(
        VkDevice                                    device,
        const VkSemaphoreCreateInfo*                pCreateInfo,
        VkSemaphore*                                pSemaphore) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO)
    deviceObject := GetDevice(device)

    semaphore := ?
    pSemaphore[0] = semaphore
    State.Semaphores[semaphore] = new!SemaphoreObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroySemaphore(
        VkDevice                                    device,
        VkSemaphore                                 semaphore) {
    deviceObject := GetDevice(device)
    semaphoreObject := GetSemaphore(semaphore)
    assert(semaphoreObject.device == device)

    State.Semaphores[semaphore] = null
}

@threadSafety("app")
cmd VkResult vkQueueSignalSemaphore(
        VkQueue                                     queue,
        VkSemaphore                                 semaphore) {
    queueObject := GetQueue(queue)
    semaphoreObject := GetSemaphore(semaphore)
    assert(queueObject.device == semaphoreObject.device)

    return ?
}

@threadSafety("system")
cmd VkResult vkQueueWaitSemaphore(
        VkQueue                                     queue,
        VkSemaphore                                 semaphore) {
    queueObject := GetQueue(queue)
    semaphoreObject := GetSemaphore(semaphore)
    assert(queueObject.device == semaphoreObject.device)

    return ?
}


// Event functions

@threadSafety("system")
cmd VkResult vkCreateEvent(
        VkDevice                                    device,
        const VkEventCreateInfo*                    pCreateInfo,
        VkEvent*                                    pEvent) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_EVENT_CREATE_INFO)
    deviceObject := GetDevice(device)

    event := ?
    pEvent[0] = event
    State.Events[event] = new!EventObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyEvent(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    State.Events[event] = null
}

@threadSafety("system")
cmd VkResult vkGetEventStatus(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    return ?
}

@threadSafety("system")
cmd VkResult vkSetEvent(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    return ?
}

@threadSafety("system")
cmd VkResult vkResetEvent(
        VkDevice                                    device,
        VkEvent                                     event) {
    deviceObject := GetDevice(device)
    eventObject := GetEvent(event)
    assert(eventObject.device == device)

    return ?
}


// Query functions

@threadSafety("system")
cmd VkResult vkCreateQueryPool(
        VkDevice                                    device,
        const VkQueryPoolCreateInfo*                pCreateInfo,
        VkQueryPool*                                pQueryPool) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO)
    deviceObject := GetDevice(device)

    queryPool := ?
    pQueryPool[0] = queryPool
    State.QueryPools[queryPool] = new!QueryPoolObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyQueryPool(
        VkDevice                                    device,
        VkQueryPool                                 queryPool) {
    deviceObject := GetDevice(device)
    queryPoolObject := GetQueryPool(queryPool)
    assert(queryPoolObject.device == device)

    State.QueryPools[queryPool] = null
}

@threadSafety("system")
cmd VkResult vkGetQueryPoolResults(
        VkDevice                                    device,
        VkQueryPool                                 queryPool,
        u32                                         startQuery,
        u32                                         queryCount,
        platform.size_t*                            pDataSize,
        void*                                       pData,
        VkQueryResultFlags                          flags) {
    deviceObject := GetDevice(device)
    queryPoolObject := GetQueryPool(queryPool)
    assert(queryPoolObject.device == device)

    dataSize := ?
    pDataSize[0] = dataSize
    data := pData[0:dataSize]

    return ?
}

// Buffer functions

@threadSafety("system")
cmd VkResult vkCreateBuffer(
        VkDevice                                    device,
        const VkBufferCreateInfo*                   pCreateInfo,
        VkBuffer*                                   pBuffer) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO)
    deviceObject := GetDevice(device)

    buffer := ?
    pBuffer[0] = buffer
    State.Buffers[buffer] = new!BufferObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyBuffer(
        VkDevice                                    device,
        VkBuffer                                    buffer) {
    deviceObject := GetDevice(device)
    bufferObject := GetBuffer(buffer)
    assert(bufferObject.device == device)

    assert(bufferObject.mem == 0)
    State.Buffers[buffer] = null
}


// Buffer view functions

@threadSafety("system")
cmd VkResult vkCreateBufferView(
        VkDevice                                    device,
        const VkBufferViewCreateInfo*               pCreateInfo,
        VkBufferView*                               pView) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO)
    deviceObject := GetDevice(device)

    bufferObject := GetBuffer(pCreateInfo.buffer)
    assert(bufferObject.device == device)

    view := ?
    pView[0] = view
    State.BufferViews[view] = new!BufferViewObject(device: device, buffer: pCreateInfo.buffer)

    return ?
}

@threadSafety("system")
cmd void vkDestroyBufferView(
        VkDevice                                    device,
        VkBufferView                                bufferView) {
    deviceObject := GetDevice(device)
    bufferViewObject := GetBufferView(bufferView)
    assert(bufferViewObject.device == device)

    State.BufferViews[bufferView] = null
}


// Image functions

@threadSafety("system")
cmd VkResult vkCreateImage(
        VkDevice                                    device,
        const VkImageCreateInfo*                    pCreateInfo,
        VkImage*                                    pImage) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO)
    deviceObject := GetDevice(device)

    image := ?
    pImage[0] = image
    State.Images[image] = new!ImageObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyImage(
        VkDevice                                    device,
        VkImage                                     image) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    assert(imageObject.mem == 0)
    State.Images[image] = null
}

cmd VkResult vkGetImageSubresourceLayout(
        VkDevice                                    device,
        VkImage                                     image,
        const VkImageSubresource*                   pSubresource,
        VkSubresourceLayout*                        pLayout) {
    deviceObject := GetDevice(device)
    imageObject := GetImage(image)
    assert(imageObject.device == device)

    return ?
}


// Image view functions

@threadSafety("system")
cmd VkResult vkCreateImageView(
        VkDevice                                    device,
        const VkImageViewCreateInfo*                pCreateInfo,
        VkImageView*                                pView) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO)
    deviceObject := GetDevice(device)

    imageObject := GetImage(pCreateInfo.image)
    assert(imageObject.device == device)

    view := ?
    pView[0] = view
    State.ImageViews[view] = new!ImageViewObject(device: device, image: pCreateInfo.image)

    return ?
}

@threadSafety("system")
cmd void vkDestroyImageView(
        VkDevice                                    device,
        VkImageView                                 imageView) {
    deviceObject := GetDevice(device)
    imageViewObject := GetImageView(imageView)
    assert(imageViewObject.device == device)

    State.ImageViews[imageView] = null
}


// Shader functions

cmd VkResult vkCreateShaderModule(
        VkDevice                                    device,
        const VkShaderModuleCreateInfo*             pCreateInfo,
        VkShaderModule*                             pShaderModule) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO)
    deviceObject := GetDevice(device)

    shaderModule := ?
    pShaderModule[0] = shaderModule
    State.ShaderModules[shaderModule] = new!ShaderModuleObject(device: device)

    return ?
}

cmd void vkDestroyShaderModule(
        VkDevice                                    device,
        VkShaderModule                              shaderModule) {
    deviceObject := GetDevice(device)
    shaderModuleObject := GetShaderModule(shaderModule)
    assert(shaderModuleObject.device == device)

    State.ShaderModules[shaderModule] = null
}

@threadSafety("system")
cmd VkResult vkCreateShader(
        VkDevice                                    device,
        const VkShaderCreateInfo*                   pCreateInfo,
        VkShader*                                   pShader) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SHADER_CREATE_INFO)
    deviceObject := GetDevice(device)

    shader := ?
    pShader[0] = shader
    State.Shaders[shader] = new!ShaderObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyShader(
        VkDevice                                    device,
        VkShader                                    shader) {
    deviceObject := GetDevice(device)
    shaderObject := GetShader(shader)
    assert(shaderObject.device == device)

    State.Shaders[shader] = null
}


// Pipeline functions

cmd VkResult vkCreatePipelineCache(
        VkDevice                                    device,
        const VkPipelineCacheCreateInfo*            pCreateInfo,
        VkPipelineCache*                            pPipelineCache) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO)
    deviceObject := GetDevice(device)

    pipelineCache := ?
    pPipelineCache[0] = pipelineCache
    State.PipelineCaches[pipelineCache] = new!PipelineCacheObject(device: device)

    return ?
}

cmd void vkDestroyPipelineCache(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache) {
    deviceObject := GetDevice(device)
    pipelineCacheObject := GetPipelineCache(pipelineCache)
    assert(pipelineCacheObject.device == device)

    State.PipelineCaches[pipelineCache] = null
}

cmd platform.size_t vkGetPipelineCacheSize(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache) {
    deviceObject := GetDevice(device)
    pipelineCacheObject := GetPipelineCache(pipelineCache)
    assert(pipelineCacheObject.device == device)

    return ?
}

cmd VkResult vkGetPipelineCacheData(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        void*                                       pData) {
    deviceObject := GetDevice(device)
    pipelineCacheObject := GetPipelineCache(pipelineCache)
    assert(pipelineCacheObject.device == device)

    return ?
}

cmd VkResult vkMergePipelineCaches(
        VkDevice                                    device,
        VkPipelineCache                             destCache,
        u32                                         srcCacheCount,
        const VkPipelineCache*                      pSrcCaches) {
    deviceObject := GetDevice(device)
    destCacheObject := GetPipelineCache(destCache)
    assert(destCacheObject.device == device)

    srcCaches := pSrcCaches[0:srcCacheCount]
    for i in (0 .. srcCacheCount) {
        srcCache := srcCaches[i]
        srcCacheObject := GetPipelineCache(srcCache)
        assert(srcCacheObject.device == device)
    }

    return ?
}

cmd VkResult vkCreateGraphicsPipelines(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        u32                                         count,
        const VkGraphicsPipelineCreateInfo*         pCreateInfos,
        VkPipeline*                                 pPipelines) {
    deviceObject := GetDevice(device)
    if pipelineCache != NULL_HANDLE {
        pipelineCacheObject := GetPipelineCache(pipelineCache)
        assert(pipelineCacheObject.device == device)
    }

    createInfos := pCreateInfos[0:count]
    pipelines := pPipelines[0:count]
    for i in (0 .. count) {
        pipeline := ?
        pipelines[i] = pipeline
        State.Pipelines[pipeline] = new!PipelineObject(device: device)
    }

    return ?
}

cmd VkResult vkCreateComputePipelines(
        VkDevice                                    device,
        VkPipelineCache                             pipelineCache,
        u32                                         count,
        const VkComputePipelineCreateInfo*          pCreateInfos,
        VkPipeline*                                 pPipelines) {
    deviceObject := GetDevice(device)
    if pipelineCache != NULL_HANDLE {
        pipelineCacheObject := GetPipelineCache(pipelineCache)
        assert(pipelineCacheObject.device == device)
    }

    createInfos := pCreateInfos[0:count]
    pipelines := pPipelines[0:count]
    for i in (0 .. count) {
        pipeline := ?
        pipelines[i] = pipeline
        State.Pipelines[pipeline] = new!PipelineObject(device: device)
    }

    return ?
}

@threadSafety("system")
cmd void vkDestroyPipeline(
        VkDevice                                    device,
        VkPipeline                                  pipeline) {
    deviceObject := GetDevice(device)
    pipelineObjects := GetPipeline(pipeline)
    assert(pipelineObjects.device == device)

    State.Pipelines[pipeline] = null
}


// Pipeline layout functions

@threadSafety("system")
cmd VkResult vkCreatePipelineLayout(
        VkDevice                                    device,
        const VkPipelineLayoutCreateInfo*           pCreateInfo,
        VkPipelineLayout*                           pPipelineLayout) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO)
    deviceObject := GetDevice(device)

    pipelineLayout := ?
    pPipelineLayout[0] = pipelineLayout
    State.PipelineLayouts[pipelineLayout] = new!PipelineLayoutObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyPipelineLayout(
        VkDevice                                    device,
        VkPipelineLayout                            pipelineLayout) {
    deviceObject := GetDevice(device)
    pipelineLayoutObjects := GetPipelineLayout(pipelineLayout)
    assert(pipelineLayoutObjects.device == device)

    State.PipelineLayouts[pipelineLayout] = null
}


// Sampler functions

@threadSafety("system")
cmd VkResult vkCreateSampler(
        VkDevice                                    device,
        const VkSamplerCreateInfo*                  pCreateInfo,
        VkSampler*                                  pSampler) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO)
    deviceObject := GetDevice(device)

    sampler := ?
    pSampler[0] = sampler
    State.Samplers[sampler] = new!SamplerObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroySampler(
        VkDevice                                    device,
        VkSampler                                   sampler) {
    deviceObject := GetDevice(device)
    samplerObject := GetSampler(sampler)
    assert(samplerObject.device == device)

    State.Samplers[sampler] = null
}


// Descriptor set functions

@threadSafety("system")
cmd VkResult vkCreateDescriptorSetLayout(
        VkDevice                                    device,
        const VkDescriptorSetLayoutCreateInfo*      pCreateInfo,
        VkDescriptorSetLayout*                      pSetLayout) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO)
    deviceObject := GetDevice(device)

    setLayout := ?
    pSetLayout[0] = setLayout
    State.DescriptorSetLayouts[setLayout] = new!DescriptorSetLayoutObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyDescriptorSetLayout(
        VkDevice                                    device,
        VkDescriptorSetLayout                       descriptorSetLayout) {
    deviceObject := GetDevice(device)
    descriptorSetLayoutObject := GetDescriptorSetLayout(descriptorSetLayout)
    assert(descriptorSetLayoutObject.device == device)

    State.DescriptorSetLayouts[descriptorSetLayout] = null
}

@threadSafety("system")
cmd VkResult vkCreateDescriptorPool(
        VkDevice                                    device,
        const VkDescriptorPoolCreateInfo*           pCreateInfo
        VkDescriptorPool*                           pDescriptorPool) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO)
    deviceObject := GetDevice(device)

    descriptorPool := ?
    pDescriptorPool[0] = descriptorPool
    State.DescriptorPools[descriptorPool] = new!DescriptorPoolObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)
    assert(descriptorPoolObject.device == device)

    State.DescriptorPools[descriptorPool] = null
}

@threadSafety("app")
cmd VkResult vkResetDescriptorPool(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)
    assert(descriptorPoolObject.device == device)

    return ?
}

@threadSafety("app")
cmd VkResult vkAllocDescriptorSets(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        VkDescriptorSetUsage                        setUsage,
        u32                                         count,
        const VkDescriptorSetLayout*                pSetLayouts,
        VkDescriptorSet*                            pDescriptorSets) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)

    setLayouts := pSetLayouts[0:count]
    for i in (0 .. count) {
        setLayout := setLayouts[i]
        setLayoutObject := GetDescriptorSetLayout(setLayout)
        assert(setLayoutObject.device == device)
    }

    descriptorSets := pDescriptorSets[0:count]
    for i in (0 .. count) {
        descriptorSet := ?
        descriptorSets[i] = descriptorSet
        State.DescriptorSets[descriptorSet] = new!DescriptorSetObject(device: device)
    }

    return ?
}

cmd VkResult vkFreeDescriptorSets(
        VkDevice                                    device,
        VkDescriptorPool                            descriptorPool,
        u32                                         count,
        const VkDescriptorSet*                      pDescriptorSets) {
    deviceObject := GetDevice(device)
    descriptorPoolObject := GetDescriptorPool(descriptorPool)

    descriptorSets := pDescriptorSets[0:count]
    for i in (0 .. count) {
        descriptorSet := descriptorSets[i]
        descriptorSetObject := GetDescriptorSet(descriptorSet)
        assert(descriptorSetObject.device == device)
        State.DescriptorSets[descriptorSet] = null
    }

    return ?
}

cmd void vkUpdateDescriptorSets(
        VkDevice                                    device,
        u32                                         writeCount,
        const VkWriteDescriptorSet*                 pDescriptorWrites,
        u32                                         copyCount,
        const VkCopyDescriptorSet*                  pDescriptorCopies) {
    deviceObject := GetDevice(device)

    descriptorWrites := pDescriptorWrites[0:writeCount]
    for i in (0 .. writeCount) {
        descriptorWrite := descriptorWrites[i]
        descriptorWriteObject := GetDescriptorSet(descriptorWrite.destSet)
        assert(descriptorWriteObject.device == device)
    }

    descriptorCopies := pDescriptorCopies[0:copyCount]
    for i in (0 .. copyCount) {
        descriptorCopy := descriptorCopies[i]
        descriptorCopyObject := GetDescriptorSet(descriptorCopy.destSet)
        assert(descriptorCopyObject.device == device)
    }
}


// Framebuffer functions

@threadSafety("system")
cmd VkResult vkCreateFramebuffer(
        VkDevice                                    device,
        const VkFramebufferCreateInfo*              pCreateInfo,
        VkFramebuffer*                              pFramebuffer) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO)
    deviceObject := GetDevice(device)

    framebuffer := ?
    pFramebuffer[0] = framebuffer
    State.Framebuffers[framebuffer] = new!FramebufferObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyFramebuffer(
        VkDevice                                    device,
        VkFramebuffer                               framebuffer) {
    deviceObject := GetDevice(device)
    framebufferObject := GetFramebuffer(framebuffer)
    assert(framebufferObject.device == device)

    State.Framebuffers[framebuffer] = null
}


// Renderpass functions

@threadSafety("system")
cmd VkResult vkCreateRenderPass(
        VkDevice                                    device,
        const VkRenderPassCreateInfo*               pCreateInfo,
        VkRenderPass*                               pRenderPass) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO)
    deviceObject := GetDevice(device)

    renderpass := ?
    pRenderPass[0] = renderpass
    State.RenderPasses[renderpass] = new!RenderPassObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyRenderPass(
        VkDevice                                    device,
        VkRenderPass                                renderPass) {
    deviceObject := GetDevice(device)
    renderPassObject := GetRenderPass(renderPass)
    assert(renderPassObject.device == device)

    State.RenderPasses[renderPass] = null
}

cmd VkResult vkGetRenderAreaGranularity(
        VkDevice                                    device,
        VkRenderPass                                renderPass,
        VkExtent2D*                                 pGranularity) {
    deviceObject := GetDevice(device)
    renderPassObject := GetRenderPass(renderPass)

    granularity := ?
    pGranularity[0] = granularity

    return ?
}

// Command pool functions

cmd VkResult vkCreateCommandPool(
        VkDevice                                    device,
        const VkCmdPoolCreateInfo*                  pCreateInfo,
        VkCmdPool*                                  pCmdPool) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_CMD_POOL_CREATE_INFO)
    deviceObject := GetDevice(device)

    cmdPool := ?
    pCmdPool[0] = cmdPool
    State.CmdPools[cmdPool] = new!CmdPoolObject(device: device)

    return ?
}

cmd void vkDestroyCommandPool(
        VkDevice                                    device,
        VkCmdPool                                   cmdPool) {
    deviceObject := GetDevice(device)
    cmdPoolObject := GetCmdPool(cmdPool)
    assert(cmdPoolObject.device == device)

    State.CmdPools[cmdPool] = null
}

cmd VkResult vkResetCommandPool(
        VkDevice                                    device,
        VkCmdPool                                   cmdPool,
        VkCmdPoolResetFlags                         flags) {
    deviceObject := GetDevice(device)
    cmdPoolObject := GetCmdPool(cmdPool)
    assert(cmdPoolObject.device == device)

    return ?
}

// Command buffer functions

macro void bindCmdBuffer(VkCmdBuffer cmdBuffer, any obj, VkDeviceMemory mem) {
    memoryObject := GetDeviceMemory(mem)
    memoryObject.boundCommandBuffers[cmdBuffer] = cmdBuffer

    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    cmdBufferObject.boundObjects[as!u64(obj)] = mem
}

macro void unbindCmdBuffer(VkCmdBuffer cmdBuffer, any obj, VkDeviceMemory mem) {
    memoryObject := GetDeviceMemory(mem)
    memoryObject.boundCommandBuffers[cmdBuffer] = null

    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    cmdBufferObject.boundObjects[as!u64(obj)] = null
}

@threadSafety("system")
cmd VkResult vkCreateCommandBuffer(
        VkDevice                                    device,
        const VkCmdBufferCreateInfo*                pCreateInfo,
        VkCmdBuffer*                                pCmdBuffer) {
    assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_CMD_BUFFER_CREATE_INFO)

    cmdBuffer := ?
    pCmdBuffer[0] = cmdBuffer
    State.CmdBuffers[cmdBuffer] = new!CmdBufferObject(device: device)

    return ?
}

@threadSafety("system")
cmd void vkDestroyCommandBuffer(
        VkDevice                                    device,
        VkCmdBuffer                                 commandBuffer) {
    deviceObject := GetDevice(device)
    cmdBufferObject := GetCmdBuffer(commandBuffer)
    assert(cmdBufferObject.device == device)

    // TODO: iterate over boundObjects and clear memory bindings
    State.CmdBuffers[commandBuffer] = null
}

@threadSafety("app")
cmd VkResult vkBeginCommandBuffer(
        VkCmdBuffer                                 cmdBuffer,
        const VkCmdBufferBeginInfo*                 pBeginInfo) {
    assert(pBeginInfo.sType == VK_STRUCTURE_TYPE_CMD_BUFFER_BEGIN_INFO)
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    // TODO: iterate over boundObjects and clear memory bindings

    return ?
}

@threadSafety("app")
cmd VkResult vkEndCommandBuffer(
        VkCmdBuffer                                 cmdBuffer) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    return ?
}

@threadSafety("app")
cmd VkResult vkResetCommandBuffer(
        VkCmdBuffer                                 cmdBuffer,
        VkCmdBufferResetFlags                       flags) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    // TODO: iterate over boundObjects and clear memory bindings

    return ?
}


// Command buffer building functions

@threadSafety("app")
cmd void vkCmdBindPipeline(
        VkCmdBuffer                                 cmdBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipeline                                  pipeline) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    pipelineObject := GetPipeline(pipeline)
    assert(cmdBufferObject.device == pipelineObject.device)

    queueFlags := cmdBufferObject.queueFlags | switch (pipelineBindPoint) {
        case VK_PIPELINE_BIND_POINT_COMPUTE:  VK_QUEUE_COMPUTE_BIT
        case VK_PIPELINE_BIND_POINT_GRAPHICS: VK_QUEUE_GRAPHICS_BIT
    }
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetViewport(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         viewportCount,
        const VkViewport*                           pViewports) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetScissor(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         scissorCount,
        const VkRect2D*                             pScissors) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetLineWidth(
        VkCmdBuffer                                 cmdBuffer,
        f32                                         lineWidth) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetDepthBias(
        VkCmdBuffer                                 cmdBuffer,
        f32                                         depthBias,
        f32                                         depthBiasClamp,
        f32                                         slopeScaledDepthBias) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetBlendConstants(
        VkCmdBuffer                                 cmdBuffer,
        // TODO(jessehall): apic only supports 'const' on pointer types. Using
        // an annotation as a quick hack to pass this to the template without
        // having to modify the AST and semantic model.
        @readonly f32[4]                            blendConst) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetDepthBounds(
        VkCmdBuffer                                 cmdBuffer,
        f32                                         minDepthBounds,
        f32                                         maxDepthBounds) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetStencilCompareMask(
        VkCmdBuffer                                 cmdBuffer,
        VkStencilFaceFlags                          faceMask,
        u32                                         stencilCompareMask) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetStencilWriteMask(
        VkCmdBuffer                                 cmdBuffer,
        VkStencilFaceFlags                          faceMask,
        u32                                         stencilWriteMask) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetStencilReference(
        VkCmdBuffer                                 cmdBuffer,
        VkStencilFaceFlags                          faceMask,
        u32                                         stencilReference) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdBindDescriptorSets(
        VkCmdBuffer                                 cmdBuffer,
        VkPipelineBindPoint                         pipelineBindPoint,
        VkPipelineLayout                            layout,
        u32                                         firstSet,
        u32                                         setCount,
        const VkDescriptorSet*                      pDescriptorSets,
        u32                                         dynamicOffsetCount,
        const u32*                                  pDynamicOffsets) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    descriptorSets := pDescriptorSets[0:setCount]
    for i in (0 .. setCount) {
        descriptorSet := descriptorSets[i]
        descriptorSetObject := GetDescriptorSet(descriptorSet)
        assert(cmdBufferObject.device == descriptorSetObject.device)
    }

    dynamicOffsets := pDynamicOffsets[0:dynamicOffsetCount]
    for i in (0 .. dynamicOffsetCount) {
        dynamicOffset := dynamicOffsets[i]
    }

    queueFlags := cmdBufferObject.queueFlags | switch (pipelineBindPoint) {
        case VK_PIPELINE_BIND_POINT_COMPUTE:  VK_QUEUE_COMPUTE_BIT
        case VK_PIPELINE_BIND_POINT_GRAPHICS: VK_QUEUE_GRAPHICS_BIT
    }
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdBindIndexBuffer(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        VkIndexType                                 indexType) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    bufferObject := GetBuffer(buffer)
    assert(cmdBufferObject.device == bufferObject.device)

    bindCmdBuffer(cmdBuffer, buffer, bufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdBindVertexBuffers(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         startBinding,
        u32                                         bindingCount,
        const VkBuffer*                             pBuffers,
        const VkDeviceSize*                         pOffsets) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    // TODO: check if not [startBinding:startBinding+bindingCount]
    buffers := pBuffers[0:bindingCount]
    offsets := pOffsets[0:bindingCount]
    for i in (0 .. bindingCount) {
        buffer := buffers[i]
        offset := offsets[i]
        bufferObject := GetBuffer(buffer)
        assert(cmdBufferObject.device == bufferObject.device)

        bindCmdBuffer(cmdBuffer, buffer, bufferObject.mem)
    }

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdDraw(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         vertexCount,
        u32                                         instanceCount,
        u32                                         firstVertex,
        u32                                         firstInstance) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdDrawIndexed(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         indexCount,
        u32                                         instanceCount,
        u32                                         firstIndex,
        s32                                         vertexOffset,
        u32                                         firstInstance) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdDrawIndirect(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        u32                                         count,
        u32                                         stride) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    bufferObject := GetBuffer(buffer)
    assert(cmdBufferObject.device == bufferObject.device)

    bindCmdBuffer(cmdBuffer, buffer, bufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdDrawIndexedIndirect(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset,
        u32                                         count,
        u32                                         stride) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    bufferObject := GetBuffer(buffer)
    assert(cmdBufferObject.device == bufferObject.device)

    bindCmdBuffer(cmdBuffer, buffer, bufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdDispatch(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         x,
        u32                                         y,
        u32                                         z) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_COMPUTE_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdDispatchIndirect(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    buffer,
        VkDeviceSize                                offset) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    bufferObject := GetBuffer(buffer)
    assert(cmdBufferObject.device == bufferObject.device)

    bindCmdBuffer(cmdBuffer, buffer, bufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_COMPUTE_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdCopyBuffer(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    srcBuffer,
        VkBuffer                                    destBuffer,
        u32                                         regionCount,
        const VkBufferCopy*                         pRegions) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    srcBufferObject := GetBuffer(srcBuffer)
    destBufferObject := GetBuffer(destBuffer)
    assert(cmdBufferObject.device == srcBufferObject.device)
    assert(cmdBufferObject.device == destBufferObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCmdBuffer(cmdBuffer, srcBuffer, srcBufferObject.mem)
    bindCmdBuffer(cmdBuffer, destBuffer, destBufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_DMA_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdCopyImage(
        VkCmdBuffer                                 cmdBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     destImage,
        VkImageLayout                               destImageLayout,
        u32                                         regionCount,
        const VkImageCopy*                          pRegions) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    srcImageObject := GetImage(srcImage)
    destImageObject := GetImage(destImage)
    assert(cmdBufferObject.device == srcImageObject.device)
    assert(cmdBufferObject.device == destImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCmdBuffer(cmdBuffer, srcImage, srcImageObject.mem)
    bindCmdBuffer(cmdBuffer, destImage, destImageObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_DMA_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdBlitImage(
        VkCmdBuffer                                 cmdBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     destImage,
        VkImageLayout                               destImageLayout,
        u32                                         regionCount,
        const VkImageBlit*                          pRegions,
        VkTexFilter                                 filter) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    srcImageObject := GetImage(srcImage)
    destImageObject := GetImage(destImage)
    assert(cmdBufferObject.device == srcImageObject.device)
    assert(cmdBufferObject.device == destImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCmdBuffer(cmdBuffer, srcImage, srcImageObject.mem)
    bindCmdBuffer(cmdBuffer, destImage, destImageObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdCopyBufferToImage(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    srcBuffer,
        VkImage                                     destImage,
        VkImageLayout                               destImageLayout,
        u32                                         regionCount,
        const VkBufferImageCopy*                    pRegions) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    srcBufferObject := GetBuffer(srcBuffer)
    destImageObject := GetImage(destImage)
    assert(cmdBufferObject.device == srcBufferObject.device)
    assert(cmdBufferObject.device == destImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCmdBuffer(cmdBuffer, srcBuffer, srcBufferObject.mem)
    bindCmdBuffer(cmdBuffer, destImage, destImageObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_DMA_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdCopyImageToBuffer(
        VkCmdBuffer                                 cmdBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkBuffer                                    destBuffer,
        u32                                         regionCount,
        const VkBufferImageCopy*                    pRegions) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    srcImageObject := GetImage(srcImage)
    destBufferObject := GetBuffer(destBuffer)
    assert(cmdBufferObject.device == srcImageObject.device)
    assert(cmdBufferObject.device == destBufferObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCmdBuffer(cmdBuffer, srcImage, srcImageObject.mem)
    bindCmdBuffer(cmdBuffer, destBuffer, destBufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_DMA_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdUpdateBuffer(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    destBuffer,
        VkDeviceSize                                destOffset,
        VkDeviceSize                                dataSize,
        const u32*                                  pData) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    destBufferObject := GetBuffer(destBuffer)
    assert(cmdBufferObject.device == destBufferObject.device)

    data := pData[0:dataSize]

    bindCmdBuffer(cmdBuffer, destBuffer, destBufferObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_DMA_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdFillBuffer(
        VkCmdBuffer                                 cmdBuffer,
        VkBuffer                                    destBuffer,
        VkDeviceSize                                destOffset,
        VkDeviceSize                                fillSize,
        u32                                         data) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    destBufferObject := GetBuffer(destBuffer)
    assert(cmdBufferObject.device == destBufferObject.device)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_DMA_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdClearColorImage(
        VkCmdBuffer                                 cmdBuffer,
        VkImage                                     image,
        VkImageLayout                               imageLayout,
        const VkClearColorValue*                    pColor,
        u32                                         rangeCount,
        const VkImageSubresourceRange*              pRanges) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    imageObject := GetImage(image)
    assert(cmdBufferObject.device == imageObject.device)

    ranges := pRanges[0:rangeCount]
    for i in (0 .. rangeCount) {
        range := ranges[i]
    }

    bindCmdBuffer(cmdBuffer, image, imageObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdClearDepthStencilImage(
        VkCmdBuffer                                 cmdBuffer,
        VkImage                                     image,
        VkImageLayout                               imageLayout,
        const VkClearDepthStencilValue*             pDepthStencil,
        u32                                         rangeCount,
        const VkImageSubresourceRange*              pRanges) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    imageObject := GetImage(image)
    assert(cmdBufferObject.device == imageObject.device)

    ranges := pRanges[0:rangeCount]
    for i in (0 .. rangeCount) {
        range := ranges[i]
    }

    bindCmdBuffer(cmdBuffer, image, imageObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdClearAttachments(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         attachmentCount,
        const VkClearAttachment*                    pAttachments,
        u32                                         rectCount,
        const VkRect3D*                             pRects) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    rects := pRects[0:rectCount]
    for i in (0 .. rectCount) {
        rect := rects[i]
    }

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdResolveImage(
        VkCmdBuffer                                 cmdBuffer,
        VkImage                                     srcImage,
        VkImageLayout                               srcImageLayout,
        VkImage                                     destImage,
        VkImageLayout                               destImageLayout,
        u32                                         regionCount,
        const VkImageResolve*                       pRegions) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    srcImageObject := GetImage(srcImage)
    destImageObject := GetImage(destImage)
    assert(cmdBufferObject.device == srcImageObject.device)
    assert(cmdBufferObject.device == destImageObject.device)

    regions := pRegions[0:regionCount]
    for i in (0 .. regionCount) {
        region := regions[i]
    }

    bindCmdBuffer(cmdBuffer, srcImage, srcImageObject.mem)
    bindCmdBuffer(cmdBuffer, destImage, destImageObject.mem)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

@threadSafety("app")
cmd void vkCmdSetEvent(
        VkCmdBuffer                                 cmdBuffer,
        VkEvent                                     event,
        VkPipelineStageFlags                        stageMask) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    eventObject := GetEvent(event)
    assert(cmdBufferObject.device == eventObject.device)
}

@threadSafety("app")
cmd void vkCmdResetEvent(
        VkCmdBuffer                                 cmdBuffer,
        VkEvent                                     event,
        VkPipelineStageFlags                        stageMask) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    eventObject := GetEvent(event)
    assert(cmdBufferObject.device == eventObject.device)
}

@threadSafety("app")
cmd void vkCmdWaitEvents(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         eventCount,
        const VkEvent*                              pEvents,
        VkPipelineStageFlags                        srcStageMask,
        VkPipelineStageFlags                        destStageMask,
        u32                                         memBarrierCount,
        const void* const*                          ppMemBarriers) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    events := pEvents[0:eventCount]
    for i in (0 .. eventCount) {
        event := events[i]
        eventObject := GetEvent(event)
        assert(cmdBufferObject.device == eventObject.device)
    }

    pMemBarriers := ppMemBarriers[0:memBarrierCount]
    for i in (0 .. memBarrierCount) {
        switch as!VkMemoryBarrier const*(pMemBarriers[i])[0].sType {
            case VK_STRUCTURE_TYPE_MEMORY_BARRIER: {
                memBarrier := as!VkMemoryBarrier const*(pMemBarriers[i])[0]
            }
            case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: {
                imageMemBarrier := as!VkImageMemoryBarrier const*(pMemBarriers[i])[0]
                imageObject := GetImage(imageMemBarrier.image)
                assert(imageObject.device == cmdBufferObject.device)
            }
            case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: {
                bufferMemBarrier := as!VkBufferMemoryBarrier const*(pMemBarriers[i])[0]
                bufferObject := GetBuffer(bufferMemBarrier.buffer)
                assert(bufferObject.device == cmdBufferObject.device)
            }
        }
    }
}

@threadSafety("app")
cmd void vkCmdPipelineBarrier(
        VkCmdBuffer                                 cmdBuffer,
        VkPipelineStageFlags                        srcStageMask,
        VkPipelineStageFlags                        destStageMask,
        VkBool32                                    byRegion,
        u32                                         memBarrierCount,
        const void* const*                          ppMemBarriers) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    pMemBarriers := ppMemBarriers[0:memBarrierCount]
    for i in (0 .. memBarrierCount) {
        switch as!VkMemoryBarrier const*(pMemBarriers[i])[0].sType {
            case VK_STRUCTURE_TYPE_MEMORY_BARRIER: {
                memBarrier := as!VkMemoryBarrier const*(pMemBarriers[i])[0]
            }
            case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: {
                imageMemBarrier := as!VkImageMemoryBarrier const*(pMemBarriers[i])[0]
                imageObject := GetImage(imageMemBarrier.image)
                assert(imageObject.device == cmdBufferObject.device)
            }
            case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: {
                bufferMemBarrier := as!VkBufferMemoryBarrier const*(pMemBarriers[i])[0]
                bufferObject := GetBuffer(bufferMemBarrier.buffer)
                assert(bufferObject.device == cmdBufferObject.device)
            }
        }
    }
}

@threadSafety("app")
cmd void vkCmdBeginQuery(
        VkCmdBuffer                                 cmdBuffer,
        VkQueryPool                                 queryPool,
        u32                                         slot,
        VkQueryControlFlags                         flags) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(cmdBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdEndQuery(
        VkCmdBuffer                                 cmdBuffer,
        VkQueryPool                                 queryPool,
        u32                                         slot) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(cmdBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdResetQueryPool(
        VkCmdBuffer                                 cmdBuffer,
        VkQueryPool                                 queryPool,
        u32                                         startQuery,
        u32                                         queryCount) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    assert(cmdBufferObject.device == queryPoolObject.device)
}

@threadSafety("app")
cmd void vkCmdWriteTimestamp(
        VkCmdBuffer                                 cmdBuffer,
        VkTimestampType                             timestampType,
        VkBuffer                                    destBuffer,
        VkDeviceSize                                destOffset) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    destBufferObject := GetBuffer(destBuffer)
    assert(cmdBufferObject.device == destBufferObject.device)
}

@threadSafety("app")
cmd void vkCmdCopyQueryPoolResults(
        VkCmdBuffer                                 cmdBuffer,
        VkQueryPool                                 queryPool,
        u32                                         startQuery,
        u32                                         queryCount,
        VkBuffer                                    destBuffer,
        VkDeviceSize                                destOffset,
        VkDeviceSize                                destStride,
        VkQueryResultFlags                          flags) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    queryPoolObject := GetQueryPool(queryPool)
    destBufferObject := GetBuffer(destBuffer)
    assert(cmdBufferObject.device == queryPoolObject.device)
    assert(cmdBufferObject.device == destBufferObject.device)
}

cmd void vkCmdPushConstants(
        VkCmdBuffer                                 cmdBuffer,
        VkPipelineLayout                            layout,
        VkShaderStageFlags                          stageFlags,
        u32                                         start,
        u32                                         length,
        const void*                                 values) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    layoutObject := GetPipelineLayout(layout)
    assert(cmdBufferObject.device == layoutObject.device)
}

@threadSafety("app")
cmd void vkCmdBeginRenderPass(
        VkCmdBuffer                                 cmdBuffer,
        const VkRenderPassBeginInfo*                pRenderPassBegin,
        VkRenderPassContents                        contents) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
    renderPassObject := GetRenderPass(pRenderPassBegin.renderPass)
    framebufferObject := GetFramebuffer(pRenderPassBegin.framebuffer)
    assert(cmdBufferObject.device == renderPassObject.device)
    assert(cmdBufferObject.device == framebufferObject.device)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

cmd void vkCmdNextSubpass(
        VkCmdBuffer                                 cmdBuffer,
        VkRenderPassContents                        contents) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)
}

@threadSafety("app")
cmd void vkCmdEndRenderPass(
        VkCmdBuffer                                 cmdBuffer) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    queueFlags := cmdBufferObject.queueFlags | VK_QUEUE_GRAPHICS_BIT
    cmdBufferObject.queueFlags = queueFlags
}

cmd void vkCmdExecuteCommands(
        VkCmdBuffer                                 cmdBuffer,
        u32                                         cmdBuffersCount,
        const VkCmdBuffer*                          pCmdBuffers) {
    cmdBufferObject := GetCmdBuffer(cmdBuffer)

    cmdBuffers := pCmdBuffers[0:cmdBuffersCount]
    for i in (0 .. cmdBuffersCount) {
        secondaryCmdBuffer := cmdBuffers[i]
        secondaryCmdBufferObject := GetCmdBuffer(secondaryCmdBuffer)
        assert(cmdBufferObject.device == secondaryCmdBufferObject.device)
    }
}

////////////////
// Extensions //
////////////////

@extension("VK_EXT_KHR_swapchain")
cmd VkResult vkGetPhysicalDeviceSurfaceSupportKHR(
        VkPhysicalDevice                        physicalDevice,
        u32                                     queueFamilyIndex,
        const VkSurfaceDescriptionKHR*          pSurfaceDescription,
        VkBool32*                               pSupported) {
    physicalDeviceObject := GetPhysicalDevice(physicalDevice)

    supported := ?
    pSupported[0] = supported

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkGetSurfacePropertiesKHR(
        VkDevice                                 device,
        const VkSurfaceDescriptionKHR*           pSurfaceDescription,
        VkSurfacePropertiesKHR*                  pSurfaceProperties) {
    deviceObject := GetDevice(device)

    surfaceProperties := ?
    pSurfaceProperties[0] = surfaceProperties

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkGetSurfaceFormatsKHR(
        VkDevice                                 device,
        const VkSurfaceDescriptionKHR*           pSurfaceDescription,
        u32*                                     pCount,
        VkSurfaceFormatKHR*                      pSurfaceFormats) {
    deviceObject := GetDevice(device)

    count := as!u32(?)
    pCount[0] = count
    surfaceFormats := pSurfaceFormats[0:count]

    for i in (0 .. count) {
        surfaceFormat := ?
        surfaceFormats[i] = surfaceFormat
    }

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkGetSurfacePresentModesKHR(
        VkDevice                                 device,
        const VkSurfaceDescriptionKHR*           pSurfaceDescription,
        u32*                                     pCount,
        VkPresentModeKHR*                        pPresentModes) {
    deviceObject := GetDevice(device)

    count := as!u32(?)
    pCount[0] = count
    presentModes := pPresentModes[0:count]

    for i in (0 .. count) {
        presentMode := ?
        presentModes[i] = presentMode
    }

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkCreateSwapchainKHR(
        VkDevice                                 device,
        const VkSwapchainCreateInfoKHR*          pCreateInfo,
        VkSwapchainKHR*                          pSwapchain) {
    //assert(pCreateInfo.sType == VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR)
    deviceObject := GetDevice(device)

    swapchain := ?
    pSwapchain[0] = swapchain
    State.Swapchains[swapchain] = new!SwapchainObject(device: device)

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkDestroySwapchainKHR(
        VkDevice                                 device,
        VkSwapchainKHR                           swapchain) {
    deviceObject := GetDevice(device)
    swapchainObject := GetSwapchain(swapchain)
    assert(swapchainObject.device == device)

    State.Swapchains[swapchain] = null

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkGetSwapchainImagesKHR(
        VkDevice                                 device,
        VkSwapchainKHR                           swapchain,
        u32*                                     pCount,
        VkImage*                                 pSwapchainImages) {
    deviceObject := GetDevice(device)

    count := as!u32(?)
    pCount[0] = count
    swapchainImages := pSwapchainImages[0:count]

    for i in (0 .. count) {
        swapchainImage := ?
        swapchainImages[i] = swapchainImage
        if !(swapchainImage in State.Images) {
            State.Images[swapchainImage] = new!ImageObject(device: device)
        }
    }

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkAcquireNextImageKHR(
        VkDevice                                 device,
        VkSwapchainKHR                           swapchain,
        u64                                      timeout,
        VkSemaphore                              semaphore,
        u32*                                     pImageIndex) {
    deviceObject := GetDevice(device)
    swapchainObject := GetSwapchain(swapchain)

    imageIndex := ?
    pImageIndex[0] = imageIndex

    return ?
}

@extension("VK_EXT_KHR_device_swapchain")
cmd VkResult vkQueuePresentKHR(
        VkQueue                                  queue,
        VkPresentInfoKHR*                        pPresentInfo) {
    queueObject := GetQueue(queue)

    presentInfo := ?
    pPresentInfo[0] = presentInfo

    return ?
}


////////////////
// Validation //
////////////////

extern void validate(string layerName, bool condition, string message)


/////////////////////////////
// Internal State Tracking //
/////////////////////////////

StateObject State

@internal class StateObject {
    // Dispatchable objects.
    map!(VkInstance,       ref!InstanceObject)       Instances
    map!(VkPhysicalDevice, ref!PhysicalDeviceObject) PhysicalDevices
    map!(VkDevice,         ref!DeviceObject)         Devices
    map!(VkQueue,          ref!QueueObject)          Queues
    map!(VkCmdBuffer,      ref!CmdBufferObject)      CmdBuffers

    // Non-dispatchable objects.
    map!(VkDeviceMemory,             ref!DeviceMemoryObject)             DeviceMemories
    map!(VkBuffer,                   ref!BufferObject)                   Buffers
    map!(VkBufferView,               ref!BufferViewObject)               BufferViews
    map!(VkImage,                    ref!ImageObject)                    Images
    map!(VkImageView,                ref!ImageViewObject)                ImageViews
    map!(VkShaderModule,             ref!ShaderModuleObject)             ShaderModules
    map!(VkShader,                   ref!ShaderObject)                   Shaders
    map!(VkPipeline,                 ref!PipelineObject)                 Pipelines
    map!(VkPipelineLayout,           ref!PipelineLayoutObject)           PipelineLayouts
    map!(VkSampler,                  ref!SamplerObject)                  Samplers
    map!(VkDescriptorSet,            ref!DescriptorSetObject)            DescriptorSets
    map!(VkDescriptorSetLayout,      ref!DescriptorSetLayoutObject)      DescriptorSetLayouts
    map!(VkDescriptorPool,           ref!DescriptorPoolObject)           DescriptorPools
    map!(VkFence,                    ref!FenceObject)                    Fences
    map!(VkSemaphore,                ref!SemaphoreObject)                Semaphores
    map!(VkEvent,                    ref!EventObject)                    Events
    map!(VkQueryPool,                ref!QueryPoolObject)                QueryPools
    map!(VkFramebuffer,              ref!FramebufferObject)              Framebuffers
    map!(VkRenderPass,               ref!RenderPassObject)               RenderPasses
    map!(VkPipelineCache,            ref!PipelineCacheObject)            PipelineCaches
    map!(VkCmdPool,                  ref!CmdPoolObject)                  CmdPools
    map!(VkSwapchainKHR,             ref!SwapchainObject)                Swapchains
}

@internal class InstanceObject {
}

@internal class PhysicalDeviceObject {
    VkInstance instance
}

@internal class DeviceObject {
    VkPhysicalDevice physicalDevice
}

@internal class QueueObject {
    VkDevice      device
    VkQueueFlags  flags
}

@internal class CmdBufferObject {
    VkDevice                  device
    map!(u64, VkDeviceMemory) boundObjects
    VkQueueFlags              queueFlags
}

@internal class DeviceMemoryObject {
    VkDevice                         device
    VkDeviceSize                     allocationSize
    map!(u64, VkDeviceSize         ) boundObjects
    map!(VkCmdBuffer, VkCmdBuffer)   boundCommandBuffers
}

@internal class BufferObject {
    VkDevice              device
    VkDeviceMemory        mem
    VkDeviceSize          memOffset
}

@internal class BufferViewObject {
    VkDevice      device
    VkBuffer      buffer
}

@internal class ImageObject {
    VkDevice              device
    VkDeviceMemory        mem
    VkDeviceSize          memOffset
}

@internal class ImageViewObject {
    VkDevice      device
    VkImage       image
}

@internal class ShaderObject {
    VkDevice      device
}

@internal class ShaderModuleObject {
    VkDevice      device
}

@internal class PipelineObject {
    VkDevice      device
}

@internal class PipelineLayoutObject {
    VkDevice      device
}

@internal class SamplerObject {
    VkDevice      device
}

@internal class DescriptorSetObject {
    VkDevice      device
}

@internal class DescriptorSetLayoutObject {
    VkDevice      device
}

@internal class DescriptorPoolObject {
    VkDevice      device
}

@internal class FenceObject {
    VkDevice      device
    bool          signaled
}

@internal class SemaphoreObject {
    VkDevice      device
}

@internal class EventObject {
    VkDevice      device
}

@internal class QueryPoolObject {
    VkDevice      device
}

@internal class FramebufferObject {
    VkDevice      device
}

@internal class RenderPassObject {
    VkDevice      device
}

@internal class PipelineCacheObject {
    VkDevice      device
}

@internal class CmdPoolObject {
    VkDevice      device
}

@internal class SwapchainObject {
    VkDevice      device
}

macro ref!InstanceObject GetInstance(VkInstance instance) {
    assert(instance in State.Instances)
    return State.Instances[instance]
}

macro ref!PhysicalDeviceObject GetPhysicalDevice(VkPhysicalDevice physicalDevice) {
    assert(physicalDevice in State.PhysicalDevices)
    return State.PhysicalDevices[physicalDevice]
}

macro ref!DeviceObject GetDevice(VkDevice device) {
    assert(device in State.Devices)
    return State.Devices[device]
}

macro ref!QueueObject GetQueue(VkQueue queue) {
    assert(queue in State.Queues)
    return State.Queues[queue]
}

macro ref!CmdBufferObject GetCmdBuffer(VkCmdBuffer cmdBuffer) {
    assert(cmdBuffer in State.CmdBuffers)
    return State.CmdBuffers[cmdBuffer]
}

macro ref!DeviceMemoryObject GetDeviceMemory(VkDeviceMemory mem) {
    assert(mem in State.DeviceMemories)
    return State.DeviceMemories[mem]
}

macro ref!BufferObject GetBuffer(VkBuffer buffer) {
    assert(buffer in State.Buffers)
    return State.Buffers[buffer]
}

macro ref!BufferViewObject GetBufferView(VkBufferView bufferView) {
    assert(bufferView in State.BufferViews)
    return State.BufferViews[bufferView]
}

macro ref!ImageObject GetImage(VkImage image) {
    assert(image in State.Images)
    return State.Images[image]
}

macro ref!ImageViewObject GetImageView(VkImageView imageView) {
    assert(imageView in State.ImageViews)
    return State.ImageViews[imageView]
}

macro ref!ShaderObject GetShader(VkShader shader) {
    assert(shader in State.Shaders)
    return State.Shaders[shader]
}

macro ref!ShaderModuleObject GetShaderModule(VkShaderModule shaderModule) {
    assert(shaderModule in State.ShaderModules)
    return State.ShaderModules[shaderModule]
}

macro ref!PipelineObject GetPipeline(VkPipeline pipeline) {
    assert(pipeline in State.Pipelines)
    return State.Pipelines[pipeline]
}

macro ref!PipelineLayoutObject GetPipelineLayout(VkPipelineLayout pipelineLayout) {
    assert(pipelineLayout in State.PipelineLayouts)
    return State.PipelineLayouts[pipelineLayout]
}

macro ref!SamplerObject GetSampler(VkSampler sampler) {
    assert(sampler in State.Samplers)
    return State.Samplers[sampler]
}

macro ref!DescriptorSetObject GetDescriptorSet(VkDescriptorSet descriptorSet) {
    assert(descriptorSet in State.DescriptorSets)
    return State.DescriptorSets[descriptorSet]
}

macro ref!DescriptorSetLayoutObject GetDescriptorSetLayout(VkDescriptorSetLayout descriptorSetLayout) {
    assert(descriptorSetLayout in State.DescriptorSetLayouts)
    return State.DescriptorSetLayouts[descriptorSetLayout]
}

macro ref!DescriptorPoolObject GetDescriptorPool(VkDescriptorPool descriptorPool) {
    assert(descriptorPool in State.DescriptorPools)
    return State.DescriptorPools[descriptorPool]
}

macro ref!FenceObject GetFence(VkFence fence) {
    assert(fence in State.Fences)
    return State.Fences[fence]
}

macro ref!SemaphoreObject GetSemaphore(VkSemaphore semaphore) {
    assert(semaphore in State.Semaphores)
    return State.Semaphores[semaphore]
}

macro ref!EventObject GetEvent(VkEvent event) {
    assert(event in State.Events)
    return State.Events[event]
}

macro ref!QueryPoolObject GetQueryPool(VkQueryPool queryPool) {
    assert(queryPool in State.QueryPools)
    return State.QueryPools[queryPool]
}

macro ref!FramebufferObject GetFramebuffer(VkFramebuffer framebuffer) {
    assert(framebuffer in State.Framebuffers)
    return State.Framebuffers[framebuffer]
}

macro ref!RenderPassObject GetRenderPass(VkRenderPass renderPass) {
    assert(renderPass in State.RenderPasses)
    return State.RenderPasses[renderPass]
}

macro ref!PipelineCacheObject GetPipelineCache(VkPipelineCache pipelineCache) {
    assert(pipelineCache in State.PipelineCaches)
    return State.PipelineCaches[pipelineCache]
}

macro ref!CmdPoolObject GetCmdPool(VkCmdPool cmdPool) {
    assert(cmdPool in State.CmdPools)
    return State.CmdPools[cmdPool]
}

macro ref!SwapchainObject GetSwapchain(VkSwapchainKHR swapchain) {
    assert(swapchain in State.Swapchains)
    return State.Swapchains[swapchain]
}
